#requires -version 2.0
function Write-Program
{
    <#
    .Synopsis
        Creates an application to run a PowerShell command.
    .Description
        Creates an application to run a PowerShell command.  
        
        The application will wrap any cmdlet and any function stored in a module and create a .exe
        
        The .exe will support all of the same parameters of the core cmdlet.
        
        You can use this to allow users to simply double click a script, rather than making a user import a module manually.
        
        All of the text output from the EXE will be shown when the EXE is complete.  Streaming is not yet supported.
    .Example
        Write-Program -Command Get-Process
        
        .\Get-Process.exe 
        
        .\Get-Process.exe -Name powershell*
    #>
    param(
    # The name of the command you're wrapping
    [Parameter(Mandatory=$true,
        ValueFromPipelineByPropertyName=$true)]
    [Alias('Name')]
    [String]$Command,
    
    # the path the command is outputting to
    [string]$OutputPath,
    
    # If this is set, the command will be a windows application.  
    # It will no longer display help or errors, but PowerShell can continue while it is running
    [switch]$WindowsApplication,
    
    # If set, this will keep the Program Debug Database (PDB file) generated by Add-Type.      
    #
    # Otherwise, this value will be thrown away    
    [switch]$KeepDebugInformation
    )
    
    process {
        $commandName = $command
        $realCommand = Get-Command $commandName | 
            Select-Object -First 1 
        if (-not $realCommand) {
            Write-Error "$command Not Found"
            return
        }        
        if ($realCommand -isnot [Management.Automation.FunctionInfo] -and
            $realCommand -isnot [Management.Automation.CmdletInfo]) {
            Write-Error "Cannot create programs that are not in a module on disk"
            return
        }
        
        if ($realCommand.Module -and -not $realCommand.Module.Path) {
            Write-Error "Cannot create programs that are not in a module on disk"
            return
        }
        
        $namespaces = '
using System;
using System.Collections;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.Management.Automation;
using System.Management.Automation.Runspaces;
'

        if ($windowsApplication) {
            $namespaces += '
using System.Windows;
using System.Windows.Controls;
'
        }

        $code = $namespaces + @'

public class Program {
    public static void Main(string[] args) {
        Collection<Object> arguments = PowerShell
            .Create()
            .AddScript(@"
$positionalParameters = New-Object Collections.ObjectModel.Collection[string]
$namedParameters = @{}
$args = @($args)
for ($i =0 ; $i -lt $args.Count; $i++) {
    if ($args[$i] -like '-*') {       
        # Named Value
        if ($args[$i] -like '-*:*') {
            # Coupled Named Value
            $parameter = $args[$i].Substring(1, $args[$i].IndexOf(':') - 1)
            $value = $args[$i].Substring($args[$i].IndexOf(':') + 1)
            $namedParameters[$parameter] = $value
        } elseif ($args[$i + 1] -notlike '-*') {
            # The next argument is the value
            if (-not ($args[$i + 1])) {
                # Really a switch, because there is no additional argument
                $namedParameters[$args[$i].Substring(1)] = $true
            } else {
                $namedParameters[$args[$i].Substring(1)] = $args[$i + 1]
                $i++ # Incremenet $i so we don't end up reusing the value
            }
        } else {
            # Assume Switch        
            $namedParameters[$args[$i].Substring(1)] = $true
        }
    } else {
        # Assume Positional Parameter    
        $positionalParameters.Add($args[$i])
    }
}
$positionalParameters 
$namedParameters")
    .AddParameters(args)
    .Invoke<Object>();    
    
    
    IDictionary namedParameters = null;
    StringCollection positionalParameters = new StringCollection();
    for (int i = 0; i < arguments.Count; i++)
    {
        if (arguments[i] is IDictionary)
        {
            namedParameters = arguments[i] as IDictionary;
        }
        if (arguments[i] is string)
        {
            positionalParameters.Add(arguments[i] as string);
        }
    }    
'@


        $code += @"
        Runspace rs = RunspaceFactory.CreateRunspace();
        rs.ApartmentState = System.Threading.ApartmentState.STA;
        rs.ThreadOptions = PSThreadOptions.ReuseThread;
        rs.Open();

        PowerShell powerShellCommand = PowerShell.Create()
            .AddCommand("Set-ExecutionPolicy")
            .AddParameter("Scope","Process")
            .AddParameter("Force")
            .AddArgument("Bypass");
        powerShellCommand.Runspace = rs;
        powerShellCommand.Invoke();
        powerShellCommand.Dispose();
        

"@    
        # If the command is in a module, we'll want to go ahead and import 
        # it.  Let's not assume it's globally available, and import by absolute path
        if ($realCommand.Module) {
            # Unfortunately, real module path is not always the module path in powershell
            $realModulePath = $realCommand.Module.Path            
            $mayberealPath = Join-Path (Split-Path $realModulePath) "$($realCommand.Module.Name).psd1"
            if ((Test-Path $mayberealPath))  {
                 $realModulePath  = $mayberealPath 
            }
            $code += @"
        powerShellCommand = PowerShell.Create()
               .AddCommand("Import-Module", false)
               .AddArgument("$($mayberealPath.Replace('\','\\'))");
        powerShellCommand.Runspace = rs;      
        try {
            powerShellCommand.Invoke();
            powerShellCommand.Dispose();
        } catch (Exception ex) {
            $(if (-not $WindowsApplication) { 'Console.WriteLine(ex.Message);' })
            $(if ($WindowsApplication) { 'MessageBox.Show(ex.Message);' })
        }
"@

        }
    
        $sma = 'System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, ProcessorArchitecture=MSIL'    
        if ($realCommand.PSSnapin -and 
            $realCommand.PSSnapin.AssemblyName -ne $sma) {
            $code += @"
        powerShellCommand = PowerShell.Create()
               .AddCommand("Add-PSSnapin", false)
               .AddArgument("$($realCommand.PSSnapin.Name)");
        powerShellCommand.Runspace = rs;      
        try {
            powerShellCommand.Invoke();
            powerShellCommand.Dispose();
        } catch (Exception ex) {
            Console.WriteLine(ex.Message);
        }
"@        
        }

        $code += @"   
        if (namedParameters.Contains("?")) {
            powerShellCommand = PowerShell.Create()
               .AddCommand("Get-Help")
               .AddArgument("$commandName");            
            powerShellCommand.Runspace = rs;

        } else {
            powerShellCommand = PowerShell.Create()
                .AddCommand("$commandName");
            powerShellCommand.Runspace = rs;

            if (namedParameters != null) {
                powerShellCommand.AddParameters(namedParameters);
            }
                
            if (positionalParameters != null) {
                powerShellCommand.AddParameters(positionalParameters);
            }        
        }                        
        
        try {            
            foreach (string str in PowerShell.Create().AddCommand("Out-String").Invoke<string>(powerShellCommand.Invoke())) {                
                Console.WriteLine(str.Trim(System.Environment.NewLine.ToCharArray()));
            }        
        } catch (Exception ex){
            $(if (-not $WindowsApplication) { 'Console.WriteLine(ex.Message);' })
            $(if ($WindowsApplication) { 'MessageBox.Show(ex.Message);' })
        }        
        
        powerShellCommand.Dispose();
        rs.Close();
        rs.Dispose();
    }
}
"@

            
        # Get the output type
        if ($windowsApplication) {
            $outputType = "windowsApplication"
        } else {
            $outputType = "consoleapplication"   
        }
        
        
        if (-not $outputPath) { $outputPath = ".\$commandName.exe" } 
        
        # resolve the output path
        $unresolvedPath = $psCmdlet.SessionState.Path.GetUnresolvedProviderPathFromPSPath("$outputPath")
        if ($unresolvedPath -notlike '*.exe') {
            Write-Warning '$unresolvedPath is not an .exe'            
        }
        $outputPath = $unresolvedPath 
    
        $addTypeParameters = @{
            TypeDefinition=$code
            Language='CSharpVersion3'
            OutputType=$outputType
            Outputassembly=$outputPath
        }
        
        Write-Verbose "
Application Code:

$Code
"
        
        if ($windowsApplication) {
            $addTypeParameters.ReferencedAssemblies = "PresentationFramework","PresentationCore","WindowsBase"
        }        
        Add-Type @addTypeParameters 
        if (Test-Path $outputPath) {
            $pdbPath = $outputPath.Replace('.exe','.pdb')
            if (-not $KeepDebugInformation) {
                Remove-Item -LiteralPath $pdbPath -ErrorAction SilentlyContinue
            }            
        }
        
        Get-Item -LiteralPath $outputPath -ErrorAction SilentlyContinue

    
    }
}

# SIG # Begin signature block
# MIINGAYJKoZIhvcNAQcCoIINCTCCDQUCAQExCzAJBgUrDgMCGgUAMGkGCisGAQQB
# gjcCAQSgWzBZMDQGCisGAQQBgjcCAR4wJgIDAQAABBAfzDtgWUsITrck0sYpfvNR
# AgEAAgEAAgEAAgEAAgEAMCEwCQYFKw4DAhoFAAQUCz6ErX+XoWmaQK2Wm8ICyAVj
# sIqgggpaMIIFIjCCBAqgAwIBAgIQAupQIxjzGlMFoE+9rHncOTANBgkqhkiG9w0B
# AQsFADByMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYD
# VQQLExB3d3cuZGlnaWNlcnQuY29tMTEwLwYDVQQDEyhEaWdpQ2VydCBTSEEyIEFz
# c3VyZWQgSUQgQ29kZSBTaWduaW5nIENBMB4XDTE0MDcxNzAwMDAwMFoXDTE1MDcy
# MjEyMDAwMFowaTELMAkGA1UEBhMCQ0ExCzAJBgNVBAgTAk9OMREwDwYDVQQHEwhI
# YW1pbHRvbjEcMBoGA1UEChMTRGF2aWQgV2F5bmUgSm9obnNvbjEcMBoGA1UEAxMT
# RGF2aWQgV2F5bmUgSm9obnNvbjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC
# ggEBAM3+T+61MoGxUHnoK0b2GgO17e0sW8ugwAH966Z1JIzQvXFa707SZvTJgmra
# ZsCn9fU+i9KhC0nUpA4hAv/b1MCeqGq1O0f3ffiwsxhTG3Z4J8mEl5eSdcRgeb+1
# jaKI3oHkbX+zxqOLSaRSQPn3XygMAfrcD/QI4vsx8o2lTUsPJEy2c0z57e1VzWlq
# KHqo18lVxDq/YF+fKCAJL57zjXSBPPmb/sNj8VgoxXS6EUAC5c3tb+CJfNP2U9vV
# oy5YeUP9bNwq2aXkW0+xZIipbJonZwN+bIsbgCC5eb2aqapBgJrgds8cw8WKiZvy
# Zx2qT7hy9HT+LUOI0l0K0w31dF8CAwEAAaOCAbswggG3MB8GA1UdIwQYMBaAFFrE
# uXsqCqOl6nEDwGD5LfZldQ5YMB0GA1UdDgQWBBTnMIKoGnZIswBx8nuJckJGsFDU
# lDAOBgNVHQ8BAf8EBAMCB4AwEwYDVR0lBAwwCgYIKwYBBQUHAwMwdwYDVR0fBHAw
# bjA1oDOgMYYvaHR0cDovL2NybDMuZGlnaWNlcnQuY29tL3NoYTItYXNzdXJlZC1j
# cy1nMS5jcmwwNaAzoDGGL2h0dHA6Ly9jcmw0LmRpZ2ljZXJ0LmNvbS9zaGEyLWFz
# c3VyZWQtY3MtZzEuY3JsMEIGA1UdIAQ7MDkwNwYJYIZIAYb9bAMBMCowKAYIKwYB
# BQUHAgEWHGh0dHBzOi8vd3d3LmRpZ2ljZXJ0LmNvbS9DUFMwgYQGCCsGAQUFBwEB
# BHgwdjAkBggrBgEFBQcwAYYYaHR0cDovL29jc3AuZGlnaWNlcnQuY29tME4GCCsG
# AQUFBzAChkJodHRwOi8vY2FjZXJ0cy5kaWdpY2VydC5jb20vRGlnaUNlcnRTSEEy
# QXNzdXJlZElEQ29kZVNpZ25pbmdDQS5jcnQwDAYDVR0TAQH/BAIwADANBgkqhkiG
# 9w0BAQsFAAOCAQEAVlkBmOEKRw2O66aloy9tNoQNIWz3AduGBfnf9gvyRFvSuKm0
# Zq3A6lRej8FPxC5Kbwswxtl2L/pjyrlYzUs+XuYe9Ua9YMIdhbyjUol4Z46jhOrO
# TDl18txaoNpGE9JXo8SLZHibwz97H3+paRm16aygM5R3uQ0xSQ1NFqDJ53YRvOqT
# 60/tF9E8zNx4hOH1lw1CDPu0K3nL2PusLUVzCpwNunQzGoZfVtlnV2x4EgXyZ9G1
# x4odcYZwKpkWPKA4bWAG+Img5+dgGEOqoUHh4jm2IKijm1jz7BRcJUMAwa2Qcbc2
# ttQbSj/7xZXL470VG3WjLWNWkRaRQAkzOajhpTCCBTAwggQYoAMCAQICEAQJGBtf
# 1btmdVNDtW+VUAgwDQYJKoZIhvcNAQELBQAwZTELMAkGA1UEBhMCVVMxFTATBgNV
# BAoTDERpZ2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3LmRpZ2ljZXJ0LmNvbTEkMCIG
# A1UEAxMbRGlnaUNlcnQgQXNzdXJlZCBJRCBSb290IENBMB4XDTEzMTAyMjEyMDAw
# MFoXDTI4MTAyMjEyMDAwMFowcjELMAkGA1UEBhMCVVMxFTATBgNVBAoTDERpZ2lD
# ZXJ0IEluYzEZMBcGA1UECxMQd3d3LmRpZ2ljZXJ0LmNvbTExMC8GA1UEAxMoRGln
# aUNlcnQgU0hBMiBBc3N1cmVkIElEIENvZGUgU2lnbmluZyBDQTCCASIwDQYJKoZI
# hvcNAQEBBQADggEPADCCAQoCggEBAPjTsxx/DhGvZ3cH0wsxSRnP0PtFmbE620T1
# f+Wondsy13Hqdp0FLreP+pJDwKX5idQ3Gde2qvCchqXYJawOeSg6funRZ9PG+ykn
# x9N7I5TkkSOWkHeC+aGEI2YSVDNQdLEoJrskacLCUvIUZ4qJRdQtoaPpiCwgla4c
# SocI3wz14k1gGL6qxLKucDFmM3E+rHCiq85/6XzLkqHlOzEcz+ryCuRXu0q16XTm
# K/5sy350OTYNkO/ktU6kqepqCquE86xnTrXE94zRICUj6whkPlKWwfIPEvTFjg/B
# ougsUfdzvL2FsWKDc0GCB+Q4i2pzINAPZHM8np+mM6n9Gd8lk9ECAwEAAaOCAc0w
# ggHJMBIGA1UdEwEB/wQIMAYBAf8CAQAwDgYDVR0PAQH/BAQDAgGGMBMGA1UdJQQM
# MAoGCCsGAQUFBwMDMHkGCCsGAQUFBwEBBG0wazAkBggrBgEFBQcwAYYYaHR0cDov
# L29jc3AuZGlnaWNlcnQuY29tMEMGCCsGAQUFBzAChjdodHRwOi8vY2FjZXJ0cy5k
# aWdpY2VydC5jb20vRGlnaUNlcnRBc3N1cmVkSURSb290Q0EuY3J0MIGBBgNVHR8E
# ejB4MDqgOKA2hjRodHRwOi8vY3JsNC5kaWdpY2VydC5jb20vRGlnaUNlcnRBc3N1
# cmVkSURSb290Q0EuY3JsMDqgOKA2hjRodHRwOi8vY3JsMy5kaWdpY2VydC5jb20v
# RGlnaUNlcnRBc3N1cmVkSURSb290Q0EuY3JsME8GA1UdIARIMEYwOAYKYIZIAYb9
# bAACBDAqMCgGCCsGAQUFBwIBFhxodHRwczovL3d3dy5kaWdpY2VydC5jb20vQ1BT
# MAoGCGCGSAGG/WwDMB0GA1UdDgQWBBRaxLl7KgqjpepxA8Bg+S32ZXUOWDAfBgNV
# HSMEGDAWgBRF66Kv9JLLgjEtUYunpyGd823IDzANBgkqhkiG9w0BAQsFAAOCAQEA
# PuwNWiSz8yLRFcgsfCUpdqgdXRwtOhrE7zBh134LYP3DPQ/Er4v97yrfIFU3sOH2
# 0ZJ1D1G0bqWOWuJeJIFOEKTuP3GOYw4TS63XX0R58zYUBor3nEZOXP+QsRsHDpEV
# +7qvtVHCjSSuJMbHJyqhKSgaOnEoAjwukaPAJRHinBRHoXpoaK+bp1wgXNlxsQyP
# u6j4xRJon89Ay0BEpRPw5mQMJQhCMrI2iiQC/i9yfhzXSUWW6Fkd6fp0ZGuy62ZD
# 2rOwjNXpDd32ASDOmTFjPQgaGLOBm0/GkxAG/AeB+ova+YJJ92JuoVP6EpQYhS6S
# kepobEQysmah5xikmmRR7zGCAigwggIkAgEBMIGGMHIxCzAJBgNVBAYTAlVTMRUw
# EwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5jb20x
# MTAvBgNVBAMTKERpZ2lDZXJ0IFNIQTIgQXNzdXJlZCBJRCBDb2RlIFNpZ25pbmcg
# Q0ECEALqUCMY8xpTBaBPvax53DkwCQYFKw4DAhoFAKB4MBgGCisGAQQBgjcCAQwx
# CjAIoAKAAKECgAAwGQYJKoZIhvcNAQkDMQwGCisGAQQBgjcCAQQwHAYKKwYBBAGC
# NwIBCzEOMAwGCisGAQQBgjcCARUwIwYJKoZIhvcNAQkEMRYEFH5g6cxIT0DWFsmO
# pOCJR2zKz2QGMA0GCSqGSIb3DQEBAQUABIIBAIebErdrlKJ2XMQucJ6Gp3pQy4yM
# HsV3KJ0NcBy5S96uanMa/CrZy8QYuHsjXG9R6FbIMjN5HwoFAb4yCv4NhddVPu20
# KNVyLCvbNKmnWpM8/Bd5wHOm1Y3oX7HHrLvQa0NraJnQQkUraKakwFeLy/UXusU3
# 9j8Jn0uAqYbaZNhSsiM7b5SKSlWQQsRFTUeU2/RpaG48RQe7iBecnaVra+opaGMF
# IP0Y31i+/khBnNl+hOJ0g6oBfOTJ3l9vaTQdXzS+LgeZCBGwGymz24NX+0alAhoA
# aBrvD9pmQNcEG2ZIusVQNWEpW1pto0AG34BXHI2APhzqRMAF/0nSW2kiPPI=
# SIG # End signature block
