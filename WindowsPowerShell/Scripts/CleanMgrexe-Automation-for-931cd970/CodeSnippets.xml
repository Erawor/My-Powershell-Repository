<?xml version="1.0" encoding="utf-8"?>
<CodeSnippets>
  <Code Content="&lt;#&#xD;&#xA;  ****************************************************************&#xD;&#xA;  * DO NOT USE IN A PRODUCTION ENVIRONMENT UNTIL YOU HAVE TESTED *&#xD;&#xA;  * THOROUGHLY IN A LAB ENVIRONMENT. USE AT YOUR OWN RISK.  IF   *&#xD;&#xA;  * YOU DO NOT UNDERSTAND WHAT THIS SCRIPT DOES OR HOW IT WORKS, *&#xD;&#xA;  * DO NOT USE IT OUTSIDE OF A SECURE, TEST SETTING.             *&#xD;&#xA;  ****************************************************************&#xD;&#xA;#&gt; &#xD;&#xA;Function Invoke-LHSDiskCleanup&#xD;&#xA;{&#xD;&#xA;&lt;#&#xD;&#xA;.SYNOPSIS&#xD;&#xA;    Invoke Disk cleanup on local or remote Windows Server 2008R2.&#xD;&#xA;&#xD;&#xA;.DESCRIPTION&#xD;&#xA;    Invoke Disk cleanup on local or remote Windows Server 2008R2 using WMI and dotNet.&#xD;&#xA;    Without the need to Install the Desktop Experience feature (by creating Reg Key structure 'CLSID'). &#xD;&#xA;    This script requires KB2852386. Run with Admin rights&#xD;&#xA;&#xD;&#xA;    This Script supports only Win Server 2008R2 English and German OS Versions&#xD;&#xA;&#xD;&#xA;    The following Elements are going to be cleaned up by default,&#xD;&#xA;    each Element can be set to $True/$False in #region Settings :&#xD;&#xA;&#xD;&#xA;        'Active Setup Temp Folders', &#xD;&#xA;        'Downloaded Program Files', &#xD;&#xA;        'Internet Cache Files', &#xD;&#xA;        'Offline Pages Files', &#xD;&#xA;        'Previous Installations', &#xD;&#xA;        'Recycle Bin',&#xD;&#xA;        'Service Pack Cleanup', &#xD;&#xA;        'System error memory dump files', &#xD;&#xA;        'System error minidump files', &#xD;&#xA;        'Temporary Setup Files',&#xD;&#xA;        'Thumbnail Cache',&#xD;&#xA;        'Update Cleanup', &#xD;&#xA;        'Upgrade Discarded Files', &#xD;&#xA;        'Windows Error Reporting Archive Files',&#xD;&#xA;        'Windows Error Reporting Queue Files', &#xD;&#xA;        'Windows Error Reporting System Archive Files', &#xD;&#xA;        'Windows Error Reporting System Queue Files', &#xD;&#xA;        'Windows Upgrade Log Files'&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;.PARAMETER ComputerName&#xD;&#xA;    The computer name to run disk Cleanup. &#xD;&#xA;    Default to local Computer&#xD;&#xA;&#xD;&#xA;.EXAMPLE&#xD;&#xA;    Invoke-LHSDiskCleanup&#xD;&#xA;&#xD;&#xA;    To run disk cleanup on the local computer.&#xD;&#xA;&#xD;&#xA;.EXAMPLE&#xD;&#xA;    Invoke-LHSDiskCleanup -ComputerName Server1 -Verbose&#xD;&#xA;&#xD;&#xA;    To run disk cleanup on 'Server1' with detailed output info&#xD;&#xA;&#xD;&#xA;.INPUTS&#xD;&#xA;    System.String, you can pipe ComputerNames to this Function&#xD;&#xA;&#xD;&#xA;.OUTPUTS&#xD;&#xA;    None to the pipeline.&#xD;&#xA;&#xD;&#xA;.NOTES&#xD;&#xA;    The Disk Cleanup executable file cleanmgr.exe and the associated Disk Cleanup button &#xD;&#xA;    are not present in Windows Server® 2008 or in Windows Server® 2008 R2 by default.&#xD;&#xA;&#xD;&#xA;    In order to use cleanmgr.exe you’ll need to copy two files that are already &#xD;&#xA;    present on the server, cleanmgr.exe and cleanmgr.exe.mui.&#xD;&#xA;    &#xD;&#xA;    For an English OS, moving cleanmgr.exe and cleanmgr.exe.mui into the correct directories &#xD;&#xA;    from within winsxs:&#xD;&#xA;    Copy-Item &quot;C:\Windows\winsxs\amd64_microsoft-windows-cleanmgr_31bf3856ad364e35_6.1.7600.16385_none_c9392808773cd7da\cleanmgr.exe&quot; C:\Windows\system32&#xD;&#xA;    Copy-Item &quot;C:\Windows\winsxs\amd64_microsoft-windows-cleanmgr.resources_31bf3856ad364e35_6.1.7600.16385_en-us_b9cb6194b257cc63\cleanmgr.exe.mui&quot; C:\Windows\System32\en-US&#xD;&#xA; &#xD;&#xA;    If you have a Server OS which is NOT en-US, then the MUI file probably needs to be &#xD;&#xA;    copied into the matching subfolder. Otherwise the process will load, but offer no UI at all. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    NOTE: on Servers where there is nothing to cleanup, the Free space in GB After the cleanup is ~ 100 MB less&#xD;&#xA;        than before. The reason is that a logfile is created under c:\Windows\Logs\CBS\CBS.log which is&#xD;&#xA;        about 100MB big in size. After a reboot this file is only about 4KB big in size and will increase again.&#xD;&#xA;        (Component Based Servicing)&#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;    Note (PL): I found out that copying these files does not enable all disk cleanup feature. &#xD;&#xA;    Options for 'System error memory dump files' or 'System error minidump files' are not available. &#xD;&#xA;    If you install the 'Desktop Experience', all these options are available. For more Info see&#xD;&#xA;    Automating Disk Cleanup Tool in Windows.docx.&#xD;&#xA;&#xD;&#xA;    'System error memory dump files' are stored under C:\Windows\memory.dmp&#xD;&#xA;    'System error minidump files' are stored under C:\Windows\Minidump\021115-19078-01.dmp&#xD;&#xA;&#xD;&#xA;    (PL)To make it work copy the following files&#xD;&#xA;    1.&#x9;C:\Windows\winsxs\amd64_microsoft-windows-dataclen_31bf3856ad364e35_6.1.7600.16385_none_529b2718ad26c095\dataclen.dll&#xD;&#xA;        Should go in  %systemroot%\System32&#xD;&#xA;    2.&#x9;C:\Windows\winsxs\amd64_microsoft-windows-dataclen.resources_31bf3856ad364e35_6.1.7600.16385_de-de_704bd9d247dc15d7\dataclen.dll.mui  &#xD;&#xA;        Should go in  %systemroot%\System32\de-DE &#xD;&#xA;        For an English system ist should go in %systemroot%\System32\en-US&#xD;&#xA;    3.&#x9;Export the following Registry structure from a Computer with Desktop Experience enabled, and import it:&#xD;&#xA;        HKEY_CLASSES_ROOT\CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}&#xD;&#xA;        (it works also exporting it from a Win 7 and import it to a win 2008R2)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    AUTHOR  : Pasquale Lantella &#xD;&#xA;    LASTEDIT: 19.05.2015&#xD;&#xA;    Version : 1.1&#xD;&#xA;        Added Hashtable for folder Names which will be cleaned. Each folder can now be enabled/disabled.&#xD;&#xA;    Version : 1.2&#xD;&#xA;        Added Copy file of dataclen.dll,dataclen.dll.mui&#xD;&#xA;        Added Create Registry Key structure: HKEY_CLASSES_ROOT\CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}&#xD;&#xA;    KEYWORDS: Disk Cleanup&#xD;&#xA;&#xD;&#xA;.LINK&#xD;&#xA;    Disk Cleanup option on drive’s general properties and cleanmgr.exe is not present in &#xD;&#xA;    Windows Server 2008 or Windows Server 2008 R2 by default&#xD;&#xA;    https://technet.microsoft.com/en-us/library/ff630161%28v=ws.10%29.aspx&#xD;&#xA;&#xD;&#xA;.LINK&#xD;&#xA;    Disk Cleanup Wizard addon lets users delete outdated Windows updates on Windows 7 SP1 &#xD;&#xA;    or Windows Server 2008 R2 SP1 &#xD;&#xA;    https://support.microsoft.com/en-us/kb/2852386&#xD;&#xA;&#xD;&#xA;.LINK&#xD;&#xA;    Automating Disk Cleanup Tool in Windows &#xD;&#xA;    https://support.microsoft.com/en-us/kb/253597/en-us&#xD;&#xA;&#xD;&#xA;.LINK&#xD;&#xA;    Creating a Disk Cleanup Handler&#xD;&#xA;    http://msdn.microsoft.com/en-us/library/bb776782.aspx&#xD;&#xA;&#xD;&#xA;#Requires -Version 2.0&#xD;&#xA;#&gt;&#xD;&#xA;   &#xD;&#xA;[cmdletbinding(  &#xD;&#xA;    ConfirmImpact = 'low',&#xD;&#xA;    SupportsShouldProcess = $false&#xD;&#xA;)]  &#xD;&#xA;&#xD;&#xA;[OutputType('None')] &#xD;&#xA;&#xD;&#xA;Param(&#xD;&#xA;    [Parameter(ParameterSetName='Default', Position=0,Mandatory=$False,ValueFromPipeline=$True,&#xD;&#xA;        HelpMessage='A computer name. The default is the local computer.')]&#xD;&#xA;&#x9;[alias(&quot;CN&quot;)]&#xD;&#xA;&#x9;[string]$ComputerName = $Env:COMPUTERNAME&#xD;&#xA;)&#xD;&#xA;&#xD;&#xA;BEGIN {&#xD;&#xA;&#xD;&#xA;    Set-StrictMode -Version Latest&#xD;&#xA;    ${CmdletName} = $Pscmdlet.MyInvocation.MyCommand.Name&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#region Settings    &#xD;&#xA;    $RegHive = 'LocalMachine'&#xD;&#xA;    $RegPath = 'SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VolumeCaches'&#xD;&#xA;    $RegValueName = 'StateFlags0032'&#xD;&#xA;&#xD;&#xA;    #Folders Names for Win 2008R2 which will been cleaned. Veryfied in Registry (EN/GER)&#xD;&#xA;    $TempFolders = @{&#xD;&#xA;        'Active Setup Temp Folders' = $true; &#xD;&#xA;        'Downloaded Program Files' = $true; &#xD;&#xA;        'Internet Cache Files' = $true;  &#xD;&#xA;        'Offline Pages Files' = $true;  &#xD;&#xA;        'Previous Installations' = $true;  &#xD;&#xA;        'Recycle Bin' = $true; &#xD;&#xA;        'Service Pack Cleanup' = $true;  &#xD;&#xA;        'System error memory dump files' = $true;  &#xD;&#xA;        'System error minidump files' = $true;  &#xD;&#xA;        'Temporary Setup Files' = $true; &#xD;&#xA;        'Thumbnail Cache' = $true; &#xD;&#xA;        'Update Cleanup' = $true;  &#xD;&#xA;        'Upgrade Discarded Files' = $true;  &#xD;&#xA;        'Windows Error Reporting Archive Files' = $true; &#xD;&#xA;        'Windows Error Reporting Queue Files' = $true;  &#xD;&#xA;        'Windows Error Reporting System Archive Files' = $true;  &#xD;&#xA;        'Windows Error Reporting System Queue Files' = $true;  &#xD;&#xA;        'Windows Upgrade Log Files' = $true;  &#xD;&#xA;    } &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#endregion Settings&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#region functions&#xD;&#xA;&#xD;&#xA;function Test-IsAdmin {&#xD;&#xA;    $currentUser = [Security.Principal.WindowsIdentity]::GetCurrent()&#xD;&#xA;&#xD;&#xA;    (New-Object Security.Principal.WindowsPrincipal $currentUser).IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;function Test-RegSubKey&#xD;&#xA;{&#xD;&#xA;# Function: Test-RegSubKey&#xD;&#xA;# Description: Test the existence of the registry key&#xD;&#xA;# Return Value: True/false respectively&#xD;&#xA;&#x9;param(&#xD;&#xA;&#x9;&#x9;[string]$ComputerName = &quot;.&quot;,&#xD;&#xA;&#x9;&#x9;[string]$hive,&#xD;&#xA;&#x9;&#x9;[string]$keyName&#xD;&#xA;&#x9;)&#xD;&#xA;&#xD;&#xA;&#x9;$hives = [enum]::getnames([Microsoft.Win32.RegistryHive])&#xD;&#xA;&#xD;&#xA;&#x9;if($hives -notcontains $hive){&#xD;&#xA;&#x9;&#x9;write-error &quot;Invalid hive value&quot;;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;$regHive = [Microsoft.Win32.RegistryHive]$hive;&#xD;&#xA;&#x9;$regKey = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey($regHive,$ComputerName);&#xD;&#xA;&#x9;$subKey = $regKey.OpenSubKey($keyName);&#xD;&#xA;&#xD;&#xA;&#x9;if(!$subKey){$false}  else {$true}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;function New-RegSubKey&#xD;&#xA;{&#xD;&#xA;# Function: New-RegSubKey&#xD;&#xA;# Description: Create the registry key&#xD;&#xA;# Return Value: True/false respectively&#xD;&#xA;&#xD;&#xA;&#x9;param(&#xD;&#xA;&#x9;&#x9;[string]$ComputerName = &quot;.&quot;,&#xD;&#xA;&#x9;&#x9;[string]$hive,&#xD;&#xA;&#x9;&#x9;[string]$keyName&#xD;&#xA;&#x9;)&#xD;&#xA;&#xD;&#xA;&#x9;$hives = [enum]::getnames([Microsoft.Win32.RegistryHive])&#xD;&#xA;&#xD;&#xA;&#x9;if($hives -notcontains $hive){&#xD;&#xA;&#x9;&#x9;write-error &quot;Invalid hive value&quot;;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;$regHive = [Microsoft.Win32.RegistryHive]$hive;&#xD;&#xA;&#x9;$regKey = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey($regHive,$ComputerName);&#xD;&#xA;&#x9;[void]$regKey.CreateSubKey($keyName);&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;if($?) {$true} else {$false}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;function Test-RegValue&#xD;&#xA;{&#xD;&#xA;# Function: Test-RegValue&#xD;&#xA;# Description: Test the existence of the registry value&#xD;&#xA;# Return Value: True/false respectively&#xD;&#xA;&#x9;param(&#xD;&#xA;&#x9;&#x9;[string]$ComputerName = $env:COMPUTERNAME,&#xD;&#xA;&#x9;&#x9;[string]$hive,&#xD;&#xA;&#x9;&#x9;[string]$keyName,&#xD;&#xA;&#x9;&#x9;[string]$valueName&#xD;&#xA;&#x9;)&#xD;&#xA;&#xD;&#xA;&#x9;$hives = [enum]::getnames([Microsoft.Win32.RegistryHive])&#xD;&#xA;&#xD;&#xA;&#x9;if($hives -notcontains $hive)&#xD;&#xA;    {&#xD;&#xA;&#x9;&#x9;write-error &quot;Invalid hive value&quot;;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;$regHive = [Microsoft.Win32.RegistryHive]$hive;&#xD;&#xA;&#x9;$regKey = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey($regHive,$ComputerName);&#xD;&#xA;&#x9;$subKey = $regKey.OpenSubKey($keyName);&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;if(!$subKey)&#xD;&#xA;    {&#xD;&#xA;&#x9;&#x9;write-error &quot;The specified registry key does not exist.&quot;;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;$regVal=$subKey.GetValue($valueName);&#xD;&#xA;&#x9;if(!$regVal){$false} else {$true}&#xD;&#xA;}#end function Test-RegValue&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;function Set-RegDefault&#xD;&#xA;{&#xD;&#xA;# Function: Set-RegDefault&#xD;&#xA;# Description: Set the registry default value&#xD;&#xA;# Return Value: True/false respectively&#xD;&#xA;&#xD;&#xA;&#x9;param(&#xD;&#xA;&#x9;&#x9;[string]$ComputerName = &quot;.&quot;,&#xD;&#xA;&#x9;&#x9;[string]$hive,&#xD;&#xA;&#x9;&#x9;[string]$keyName,&#xD;&#xA;        [ValidateSet('String','ExpandString','DWord')]&#xD;&#xA;        [string]$Type,&#xD;&#xA;&#x9;&#x9;$value&#x9;&#xD;&#xA;&#x9;)&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;$hives = [enum]::getnames([Microsoft.Win32.RegistryHive])&#xD;&#xA;&#xD;&#xA;&#x9;if($hives -notcontains $hive){&#xD;&#xA;&#x9;&#x9;write-error &quot;Invalid hive value&quot;;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;$regHive = [Microsoft.Win32.RegistryHive]$hive;&#xD;&#xA;&#x9;$regKey = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey($regHive,$ComputerName);&#xD;&#xA;&#x9;$subKey = $regKey.OpenSubKey($keyName,$true);&#xD;&#xA;&#xD;&#xA;&#x9;if(!$subKey){&#xD;&#xA;&#x9;&#x9;write-error &quot;The specified registry key does not exist.&quot;;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;    Switch ($Type)&#xD;&#xA;    {&#xD;&#xA;&#x9;    'String' {#$regKey.SetValue($null, $value,[Microsoft.Win32.RegistryValueKind]::String);&#xD;&#xA;&#x9;            $subKey.SetValue($null, $value,[Microsoft.Win32.RegistryValueKind]::String);}&#xD;&#xA;&#xD;&#xA;        'ExpandString' { $subKey.SetValue($null, $value,[Microsoft.Win32.RegistryValueKind]::ExpandString); }&#xD;&#xA;&#xD;&#xA;        'DWord' { $subKey.SetValue($null, $value,[Microsoft.Win32.RegistryValueKind]::DWord); }&#xD;&#xA;    &#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;if($?) {$true} else {$false}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;function Set-RegString&#xD;&#xA;{&#xD;&#xA;# Function: Set-RegString&#xD;&#xA;# Description: Create/Update the specified registry string value&#xD;&#xA;# Return Value: True/false respectively&#xD;&#xA;&#x9;param(&#xD;&#xA;&#x9;&#x9;[string]$ComputerName = &quot;.&quot;,&#xD;&#xA;&#x9;&#x9;[string]$hive,&#xD;&#xA;&#x9;&#x9;[string]$keyName,&#xD;&#xA;&#x9;&#x9;[string]$valueName,&#xD;&#xA;&#x9;&#x9;[string]$value&#x9;&#xD;&#xA;&#x9;)&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;$hives = [enum]::getnames([Microsoft.Win32.RegistryHive])&#xD;&#xA;&#xD;&#xA;&#x9;if($hives -notcontains $hive){&#xD;&#xA;&#x9;&#x9;write-error &quot;Invalid hive value&quot;;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;$regHive = [Microsoft.Win32.RegistryHive]$hive;&#xD;&#xA;&#x9;$regKey = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey($regHive,$ComputerName);&#xD;&#xA;&#x9;$subKey = $regKey.OpenSubKey($keyName,$true);&#xD;&#xA;&#xD;&#xA;&#x9;if(!$subKey){&#xD;&#xA;&#x9;&#x9;write-error &quot;The specified registry key does not exist.&quot;;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;$subKey.SetValue($valueName, $value, [Microsoft.Win32.RegistryValueKind]::String);&#xD;&#xA;&#x9;if($?) {$true} else {$false}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;function Set-RegDWord&#xD;&#xA;{&#xD;&#xA;# Function: Set-RegDWord&#xD;&#xA;# Description: Create/Update the registry value (REG_DWORD)&#xD;&#xA;# Return Value: True/false respectively&#xD;&#xA;&#x9;param(&#xD;&#xA;&#x9;&#x9;[string]$ComputerName = $env:COMPUTERNAME,&#xD;&#xA;&#x9;&#x9;[string]$hive,&#xD;&#xA;&#x9;&#x9;[string]$keyName,&#xD;&#xA;&#x9;&#x9;[string]$valueName,&#xD;&#xA;&#x9;&#x9;[double]$value&#x9;&#xD;&#xA;&#x9;)&#xD;&#xA;&#xD;&#xA;&#x9;$hives = [enum]::getnames([Microsoft.Win32.RegistryHive])&#xD;&#xA;&#xD;&#xA;&#x9;if($hives -notcontains $hive)&#xD;&#xA;    {&#xD;&#xA;&#x9;&#x9;write-error &quot;Invalid hive value&quot;;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;$regHive = [Microsoft.Win32.RegistryHive]$hive;&#xD;&#xA;&#x9;$regKey = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey($regHive,$ComputerName);&#xD;&#xA;&#x9;$subKey = $regKey.OpenSubKey($keyName,$true);&#xD;&#xA;&#xD;&#xA;&#x9;if(!$subKey){&#xD;&#xA;&#x9;&#x9;write-error &quot;The specified registry key does not exist.&quot;;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;$subKey.SetValue($valueName, $value,[Microsoft.Win32.RegistryValueKind]::DWord);&#xD;&#xA;&#x9;if($?) {$true} else {$false}&#xD;&#xA;}#end function Set-RegDWord&#xD;&#xA;&#xD;&#xA;#endregion functions&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;} # end BEGIN&#xD;&#xA;&#xD;&#xA;PROCESS {&#xD;&#xA;&#xD;&#xA;    If (-not (Test-IsAdmin)) { Write-Warning &quot;This script requires Admin rights.&quot; ; return}&#xD;&#xA;&#xD;&#xA;    IF (Test-Connection -ComputerName $ComputerName -count 2 -quiet) &#xD;&#xA;    {    &#xD;&#xA;        Try&#xD;&#xA;        {    &#xD;&#xA;            # ensure we're running on Windows Server 2008R2 &#xD;&#xA;            $OS = Get-WmiObject -Class Win32_OperatingSystem -ComputerName $ComputerName -Property Version, ProductType, OSLanguage -ErrorAction Stop&#xD;&#xA;            If (($OS.Version -like '6.1*') -and ($OS.ProductType -eq 3))&#xD;&#xA;            {&#xD;&#xA;                Write-Verbose &quot;Windows Server 2008R2 detected&quot; -Verbose&#xD;&#xA;                Try{Get-HotFix -ComputerName $ComputerName -Id kb2852386 -ErrorAction Stop | Out-Null}&#xD;&#xA;                Catch {Write-Warning &quot;KB2852386 is required. Please install hotfix and re-run.&quot;;return}&#xD;&#xA;&#xD;&#xA;                Switch ($OS.OSLanguage)&#xD;&#xA;                {&#xD;&#xA;                    '1031' { Write-Verbose &quot;OS = German&quot;&#xD;&#xA;             &#xD;&#xA;                            Copy-Item &quot;\\$ComputerName\C$\Windows\winsxs\amd64_microsoft-windows-cleanmgr_31bf3856ad364e35_6.1.7600.16385_none_c9392808773cd7da\cleanmgr.exe&quot; &quot;\\$ComputerName\C$\Windows\system32&quot; -ErrorAction Stop&#xD;&#xA;                            Copy-Item &quot;\\$ComputerName\C$\Windows\winsxs\amd64_microsoft-windows-cleanmgr.resources_31bf3856ad364e35_6.1.7600.16385_de-de_10da8b9bc379c09e\cleanmgr.exe.mui&quot; &quot;\\$ComputerName\C$\Windows\System32\de-DE&quot; -ErrorAction Stop&#xD;&#xA;&#xD;&#xA;                            Copy-Item &quot;\\$ComputerName\C$\Windows\winsxs\amd64_microsoft-windows-dataclen_31bf3856ad364e35_6.1.7600.16385_none_529b2718ad26c095\dataclen.dll&quot; &quot;\\$ComputerName\C$\Windows\system32&quot; -ErrorAction Stop&#xD;&#xA;                            Copy-Item &quot;\\$ComputerName\C$\Windows\winsxs\amd64_microsoft-windows-dataclen.resources_31bf3856ad364e35_6.1.7600.16385_de-de_704bd9d247dc15d7\dataclen.dll.mui&quot; &quot;\\$ComputerName\C$\Windows\System32\de-DE&quot; -ErrorAction Stop&#xD;&#xA;                        }&#xD;&#xA;                    '1033' { Write-Verbose &quot;OS = English_US&quot;&#xD;&#xA;    &#xD;&#xA;                            Copy-Item &quot;\\$ComputerName\C$\Windows\winsxs\amd64_microsoft-windows-cleanmgr_31bf3856ad364e35_6.1.7600.16385_none_c9392808773cd7da\cleanmgr.exe&quot; &quot;\\$ComputerName\C$\Windows\system32&quot; -ErrorAction Stop&#xD;&#xA;                            Copy-Item &quot;\\$ComputerName\C$\Windows\winsxs\amd64_microsoft-windows-cleanmgr.resources_31bf3856ad364e35_6.1.7600.16385_en-us_b9cb6194b257cc63\cleanmgr.exe.mui&quot; &quot;\\$ComputerName\C$\Windows\System32\en-US&quot; -ErrorAction Stop&#xD;&#xA;&#xD;&#xA;                            Copy-Item &quot;\\$ComputerName\c$\windows\winsxs\amd64_microsoft-windows-dataclen_31bf3856ad364e35_6.1.7600.16385_none_529b2718ad26c095\dataclen.dll&quot; &quot;\\$ComputerName\C$\Windows\system32&quot; -ErrorAction Stop&#xD;&#xA;                            Copy-Item &quot;\\$ComputerName\c$\windows\winsxs\amd64_microsoft-windows-dataclen.resources_31bf3856ad364e35_6.1.7600.16385_en-us_193cafcb36ba219c\dataclen.dll.mui&quot; &quot;\\$ComputerName\C$\Windows\System32\en-US&quot; -ErrorAction Stop&#xD;&#xA;                         }&#xD;&#xA;                    Default { Write-Warning &quot;OS Language [$($OS.OSLanguage)] not Supported for this Script&quot;; return }&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;            }&#xD;&#xA;            Else&#xD;&#xA;            {&#xD;&#xA;                Write-Warning &quot;This script is for Windows Server 2008R2 only&quot;&#xD;&#xA;                return&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            ($TempFolders.GetEnumerator() | Sort-Object Name) | Out-String | Write-Verbose &#xD;&#xA;&#xD;&#xA;#region Reg_CLSID&#xD;&#xA;            # save the current Setting&#xD;&#xA;            $DefaultErrorActionPreference = $ErrorActionPreference.ToString()&#xD;&#xA;            $ErrorActionPreference = 'Stop'  &#xD;&#xA;             &#xD;&#xA;            # create Registry CLSID structure for Disk Cleanup Manager&#xD;&#xA;            If (-not (Test-RegSubKey -ComputerName $ComputerName -hive 'ClassesRoot' -keyName 'CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}'))&#xD;&#xA;            {&#xD;&#xA;&#xD;&#xA;                Write-Verbose &quot;Creating RegKey \\$ComputerName\HKEY_CLASSES_ROOT\CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6} ...&quot;&#xD;&#xA;                New-RegSubKey -ComputerName $ComputerName -hive 'ClassesRoot' -keyName 'CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}'&#xD;&#xA;&#xD;&#xA;                Write-Verbose &quot;Creating RegKey \\$ComputerName\HKEY_CLASSES_ROOT\CLSID\{C1060E7E-7939-44A5-99C3-A6DCCD92AED0}\InProcServer32 ...&quot;&#xD;&#xA;                New-RegSubKey -ComputerName $ComputerName -hive 'ClassesRoot' -keyName 'CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}\InProcServer32'&#xD;&#xA;&#xD;&#xA;                Write-Verbose &quot;Creating Default RegValue at \\$ComputerName\HKEY_CLASSES_ROOT\CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6} ...&quot;&#xD;&#xA;                # Reg_SZ&#xD;&#xA;                Set-RegDefault -ComputerName $ComputerName -hive 'ClassesRoot' -keyName 'CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}' -Type String -value 'Data Driven Cleaner' &#xD;&#xA;&#xD;&#xA;                Write-Verbose &quot;Creating Default RegValue at \\$ComputerName\HKEY_CLASSES_ROOT\CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}\InProcServer32 ...&quot;&#xD;&#xA;                # Reg_EXPAND_SZ&#xD;&#xA;                Set-RegDefault -ComputerName $ComputerName -hive 'ClassesRoot' -keyName 'CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}\InProcServer32' -Type ExpandString -value '%SystemRoot%\System32\DATACLEN.DLL' &#xD;&#xA;&#xD;&#xA;                 Write-Verbose &quot;Creating 'Apartment' RegValue at \\$ComputerName\HKEY_CLASSES_ROOT\CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}\InProcServer32 ...&quot;&#xD;&#xA;                # Reg_SZ&#xD;&#xA;                Set-RegString -ComputerName $ComputerName -hive 'ClassesRoot' -keyName 'CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}\InProcServer32' -valueName 'ThreadingModel' -value 'Apartment'&#xD;&#xA;&#xD;&#xA;            }&#xD;&#xA;            # Reset to Default&#xD;&#xA;            $ErrorActionPreference = $DefaultErrorActionPreference &#xD;&#xA;#endregion Reg_CLSID&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#region Reg_StateFlags&#xD;&#xA;            #Set StateFlags setting for each item of disk cleanup utility&#xD;&#xA;            foreach ($TemFolder in ($TempFolders.GetEnumerator() | Sort-Object Name).Key)&#xD;&#xA;            {&#xD;&#xA;                $RegKey = $RegPath + &quot;\&quot; + $TemFolder&#xD;&#xA;                &#xD;&#xA;                If ($TempFolders.$TemFolder)&#xD;&#xA;                {&#xD;&#xA;                    #Include this handler when this profile is run.&#xD;&#xA;                    If (-Not (Set-RegDWord -ComputerName $ComputerName -hive $RegHive -keyName $RegKey -valueName $RegValueName -value 2))&#xD;&#xA;                    {&#xD;&#xA;                        Write-Error &quot;Could not set RegValue \\$ComputerName\$RegHive\$RegKey\$RegValueName&quot;&#xD;&#xA;                        return&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;                Else&#xD;&#xA;                {&#xD;&#xA;                    # Do not run this handler when this profile is run.&#xD;&#xA;                    If (-Not (Set-RegDWord -ComputerName $ComputerName -hive $RegHive -keyName $RegKey -valueName $RegValueName -value 0))&#xD;&#xA;                    {&#xD;&#xA;                        Write-Error &quot;Could not set RegValue \\$ComputerName\$RegHive\$RegKey\$RegValueName&quot;&#xD;&#xA;                        return&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;             } #end foreach ($TemFolder in $TempFolders)&#xD;&#xA;#endregion Reg_StateFlags&#xD;&#xA;&#xD;&#xA;            #Capture current free disk space on Drive C:&#xD;&#xA;            $FreespaceBefore = (Get-WmiObject -Class win32_logicaldisk -ComputerName $ComputerName -filter &quot;DeviceID='C:'&quot; | select Freespace).FreeSpace/1GB&#xD;&#xA;&#xD;&#xA;    &#xD;&#xA;            # Invoke cleanmgr.exe on local or remote Computer&#xD;&#xA;            $WMIParam = @{&#xD;&#xA;                Path = 'Win32_Process';&#xD;&#xA;                ComputerName = $ComputerName;&#x9;&#xD;&#xA;                Name = 'Create';&#xD;&#xA;                ArgumentList = 'cleanmgr.exe /sagerun:32'; &#xD;&#xA;            }&#xD;&#xA;            Try &#xD;&#xA;            {&#xD;&#xA;                Invoke-WmiMethod @WMIParam -ErrorAction Stop | Out-Null&#xD;&#xA;            } &#xD;&#xA;            Catch &#xD;&#xA;            {&#xD;&#xA;                Write-Warning (&quot;{0}: {1}&quot; -f $ComputerName,$_.Exception.Message)&#xD;&#xA;                return&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            do &#xD;&#xA;            {&#xD;&#xA;                Write-Host &quot;waiting for cleanmgr to complete. . .&quot;&#xD;&#xA;                start-sleep 5&#xD;&#xA;            } while ((Get-WmiObject -Class win32_process -ComputerName $ComputerName | Where-Object {$_.processname -eq 'cleanmgr.exe'} | measure).count)&#xD;&#xA;&#xD;&#xA;            #Capture free disk space after cleanmgr on Drive C:&#xD;&#xA;            $FreespaceAfter = (Get-WmiObject -Class win32_logicaldisk -ComputerName $ComputerName -filter &quot;DeviceID='C:'&quot; | select Freespace).FreeSpace/1GB&#xD;&#xA;&#xD;&#xA;            Write-Host &quot; &quot;    &#xD;&#xA;            &quot;Free Space in GB Before: {0:N3}&quot; -f $FreespaceBefore&#xD;&#xA;            &quot;Free Space in GB After : {0:N3}&quot; -f $FreespaceAfter                &#xD;&#xA;    &#xD;&#xA;            Write-Host  &quot;Disk Cleanup was successfully&quot; -ForegroundColor Green &#xD;&#xA;&#xD;&#xA;         }&#xD;&#xA;         Catch&#xD;&#xA;         {&#xD;&#xA;            Write-Error (&quot;{0}: {1}&quot; -f $ComputerName,$_.Exception.Message)&#xD;&#xA;         }   &#xD;&#xA;&#xD;&#xA;    } &#xD;&#xA;    Else &#xD;&#xA;    {&#xD;&#xA;        Write-Warning &quot;\\$ComputerName DO NOT reply to ping&quot; &#xD;&#xA;    } # end IF (Test-Connection -ComputerName $ComputerName -count 2 -quiet)    &#xD;&#xA;&#xD;&#xA;} # end PROCESS&#xD;&#xA;&#xD;&#xA;END { Write-Verbose &quot;Function ${CmdletName} finished.&quot; }&#xD;&#xA;&#xD;&#xA;} # end Function Invoke-LHSDiskCleanup      &#xD;&#xA;             &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <Code Content="&lt;#&#xD;&#xA;  ****************************************************************&#xD;&#xA;  * DO NOT USE IN A PRODUCTION ENVIRONMENT UNTIL YOU HAVE TESTED *&#xD;&#xA;  * THOROUGHLY IN A LAB ENVIRONMENT. USE AT YOUR OWN RISK.  IF   *&#xD;&#xA;  * YOU DO NOT UNDERSTAND WHAT THIS SCRIPT DOES OR HOW IT WORKS, *&#xD;&#xA;  * DO NOT USE IT OUTSIDE OF A SECURE, TEST SETTING.             *&#xD;&#xA;  ****************************************************************&#xD;&#xA;#&gt; &#xD;&#xA;Function Invoke-LHSDiskCleanup&#xD;&#xA;{&#xD;&#xA;&lt;#&#xD;&#xA;.SYNOPSIS&#xD;&#xA;    Invoke Disk cleanup on local or remote Windows Server 2008R2.&#xD;&#xA;&#xD;&#xA;.DESCRIPTION&#xD;&#xA;    Invoke Disk cleanup on local or remote Windows Server 2008R2 using WMI and dotNet.&#xD;&#xA;    Without the need to Install the Desktop Experience feature (by creating Reg Key structure 'CLSID'). &#xD;&#xA;    This script requires KB2852386. Run with Admin rights&#xD;&#xA;&#xD;&#xA;    This Script supports only Win Server 2008R2 English and German OS Versions&#xD;&#xA;&#xD;&#xA;    The following Elements are going to be cleaned up by default,&#xD;&#xA;    each Element can be set to $True/$False in #region Settings :&#xD;&#xA;&#xD;&#xA;        'Active Setup Temp Folders', &#xD;&#xA;        'Downloaded Program Files', &#xD;&#xA;        'Internet Cache Files', &#xD;&#xA;        'Offline Pages Files', &#xD;&#xA;        'Previous Installations', &#xD;&#xA;        'Recycle Bin',&#xD;&#xA;        'Service Pack Cleanup', &#xD;&#xA;        'System error memory dump files', &#xD;&#xA;        'System error minidump files', &#xD;&#xA;        'Temporary Setup Files',&#xD;&#xA;        'Thumbnail Cache',&#xD;&#xA;        'Update Cleanup', &#xD;&#xA;        'Upgrade Discarded Files', &#xD;&#xA;        'Windows Error Reporting Archive Files',&#xD;&#xA;        'Windows Error Reporting Queue Files', &#xD;&#xA;        'Windows Error Reporting System Archive Files', &#xD;&#xA;        'Windows Error Reporting System Queue Files', &#xD;&#xA;        'Windows Upgrade Log Files'&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;.PARAMETER ComputerName&#xD;&#xA;    The computer name to run disk Cleanup. &#xD;&#xA;    Default to local Computer&#xD;&#xA;&#xD;&#xA;.EXAMPLE&#xD;&#xA;    Invoke-LHSDiskCleanup&#xD;&#xA;&#xD;&#xA;    To run disk cleanup on the local computer.&#xD;&#xA;&#xD;&#xA;.EXAMPLE&#xD;&#xA;    Invoke-LHSDiskCleanup -ComputerName Server1 -Verbose&#xD;&#xA;&#xD;&#xA;    To run disk cleanup on 'Server1' with detailed output info&#xD;&#xA;&#xD;&#xA;.INPUTS&#xD;&#xA;    System.String, you can pipe ComputerNames to this Function&#xD;&#xA;&#xD;&#xA;.OUTPUTS&#xD;&#xA;    None to the pipeline.&#xD;&#xA;&#xD;&#xA;.NOTES&#xD;&#xA;    The Disk Cleanup executable file cleanmgr.exe and the associated Disk Cleanup button &#xD;&#xA;    are not present in Windows Server® 2008 or in Windows Server® 2008 R2 by default.&#xD;&#xA;&#xD;&#xA;    In order to use cleanmgr.exe you’ll need to copy two files that are already &#xD;&#xA;    present on the server, cleanmgr.exe and cleanmgr.exe.mui.&#xD;&#xA;    &#xD;&#xA;    For an English OS, moving cleanmgr.exe and cleanmgr.exe.mui into the correct directories &#xD;&#xA;    from within winsxs:&#xD;&#xA;    Copy-Item &quot;C:\Windows\winsxs\amd64_microsoft-windows-cleanmgr_31bf3856ad364e35_6.1.7600.16385_none_c9392808773cd7da\cleanmgr.exe&quot; C:\Windows\system32&#xD;&#xA;    Copy-Item &quot;C:\Windows\winsxs\amd64_microsoft-windows-cleanmgr.resources_31bf3856ad364e35_6.1.7600.16385_en-us_b9cb6194b257cc63\cleanmgr.exe.mui&quot; C:\Windows\System32\en-US&#xD;&#xA; &#xD;&#xA;    If you have a Server OS which is NOT en-US, then the MUI file probably needs to be &#xD;&#xA;    copied into the matching subfolder. Otherwise the process will load, but offer no UI at all. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    NOTE: on Servers where there is nothing to cleanup, the Free space in GB After the cleanup is ~ 100 MB less&#xD;&#xA;        than before. The reason is that a logfile is created under c:\Windows\Logs\CBS\CBS.log which is&#xD;&#xA;        about 100MB big in size. After a reboot this file is only about 4KB big in size and will increase again.&#xD;&#xA;        (Component Based Servicing)&#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;    Note (PL): I found out that copying these files does not enable all disk cleanup feature. &#xD;&#xA;    Options for 'System error memory dump files' or 'System error minidump files' are not available. &#xD;&#xA;    If you install the 'Desktop Experience', all these options are available. For more Info see&#xD;&#xA;    Automating Disk Cleanup Tool in Windows.docx.&#xD;&#xA;&#xD;&#xA;    'System error memory dump files' are stored under C:\Windows\memory.dmp&#xD;&#xA;    'System error minidump files' are stored under C:\Windows\Minidump\021115-19078-01.dmp&#xD;&#xA;&#xD;&#xA;    (PL)To make it work copy the following files&#xD;&#xA;    1.&#x9;C:\Windows\winsxs\amd64_microsoft-windows-dataclen_31bf3856ad364e35_6.1.7600.16385_none_529b2718ad26c095\dataclen.dll&#xD;&#xA;        Should go in  %systemroot%\System32&#xD;&#xA;    2.&#x9;C:\Windows\winsxs\amd64_microsoft-windows-dataclen.resources_31bf3856ad364e35_6.1.7600.16385_de-de_704bd9d247dc15d7\dataclen.dll.mui  &#xD;&#xA;        Should go in  %systemroot%\System32\de-DE &#xD;&#xA;        For an English system ist should go in %systemroot%\System32\en-US&#xD;&#xA;    3.&#x9;Export the following Registry structure from a Computer with Desktop Experience enabled, and import it:&#xD;&#xA;        HKEY_CLASSES_ROOT\CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}&#xD;&#xA;        (it works also exporting it from a Win 7 and import it to a win 2008R2)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    AUTHOR  : Pasquale Lantella &#xD;&#xA;    LASTEDIT: 19.05.2015&#xD;&#xA;    Version : 1.1&#xD;&#xA;        Added Hashtable for folder Names which will be cleaned. Each folder can now be enabled/disabled.&#xD;&#xA;    Version : 1.2&#xD;&#xA;        Added Copy file of dataclen.dll,dataclen.dll.mui&#xD;&#xA;        Added Create Registry Key structure: HKEY_CLASSES_ROOT\CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}&#xD;&#xA;    KEYWORDS: Disk Cleanup&#xD;&#xA;&#xD;&#xA;.LINK&#xD;&#xA;    Disk Cleanup option on drive’s general properties and cleanmgr.exe is not present in &#xD;&#xA;    Windows Server 2008 or Windows Server 2008 R2 by default&#xD;&#xA;    https://technet.microsoft.com/en-us/library/ff630161%28v=ws.10%29.aspx&#xD;&#xA;&#xD;&#xA;.LINK&#xD;&#xA;    Disk Cleanup Wizard addon lets users delete outdated Windows updates on Windows 7 SP1 &#xD;&#xA;    or Windows Server 2008 R2 SP1 &#xD;&#xA;    https://support.microsoft.com/en-us/kb/2852386&#xD;&#xA;&#xD;&#xA;.LINK&#xD;&#xA;    Automating Disk Cleanup Tool in Windows &#xD;&#xA;    https://support.microsoft.com/en-us/kb/253597/en-us&#xD;&#xA;&#xD;&#xA;.LINK&#xD;&#xA;    Creating a Disk Cleanup Handler&#xD;&#xA;    http://msdn.microsoft.com/en-us/library/bb776782.aspx&#xD;&#xA;&#xD;&#xA;#Requires -Version 2.0&#xD;&#xA;#&gt;&#xD;&#xA;   &#xD;&#xA;[cmdletbinding(  &#xD;&#xA;    ConfirmImpact = 'low',&#xD;&#xA;    SupportsShouldProcess = $false&#xD;&#xA;)]  &#xD;&#xA;&#xD;&#xA;[OutputType('None')] &#xD;&#xA;&#xD;&#xA;Param(&#xD;&#xA;    [Parameter(ParameterSetName='Default', Position=0,Mandatory=$False,ValueFromPipeline=$True,&#xD;&#xA;        HelpMessage='A computer name. The default is the local computer.')]&#xD;&#xA;&#x9;[alias(&quot;CN&quot;)]&#xD;&#xA;&#x9;[string]$ComputerName = $Env:COMPUTERNAME&#xD;&#xA;)&#xD;&#xA;&#xD;&#xA;BEGIN {&#xD;&#xA;&#xD;&#xA;    Set-StrictMode -Version Latest&#xD;&#xA;    ${CmdletName} = $Pscmdlet.MyInvocation.MyCommand.Name&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#region Settings    &#xD;&#xA;    $RegHive = 'LocalMachine'&#xD;&#xA;    $RegPath = 'SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VolumeCaches'&#xD;&#xA;    $RegValueName = 'StateFlags0032'&#xD;&#xA;&#xD;&#xA;    #Folders Names for Win 2008R2 which will been cleaned. Veryfied in Registry (EN/GER)&#xD;&#xA;    $TempFolders = @{&#xD;&#xA;        'Active Setup Temp Folders' = $true; &#xD;&#xA;        'Downloaded Program Files' = $true; &#xD;&#xA;        'Internet Cache Files' = $true;  &#xD;&#xA;        'Offline Pages Files' = $true;  &#xD;&#xA;        'Previous Installations' = $true;  &#xD;&#xA;        'Recycle Bin' = $true; &#xD;&#xA;        'Service Pack Cleanup' = $true;  &#xD;&#xA;        'System error memory dump files' = $true;  &#xD;&#xA;        'System error minidump files' = $true;  &#xD;&#xA;        'Temporary Setup Files' = $true; &#xD;&#xA;        'Thumbnail Cache' = $true; &#xD;&#xA;        'Update Cleanup' = $true;  &#xD;&#xA;        'Upgrade Discarded Files' = $true;  &#xD;&#xA;        'Windows Error Reporting Archive Files' = $true; &#xD;&#xA;        'Windows Error Reporting Queue Files' = $true;  &#xD;&#xA;        'Windows Error Reporting System Archive Files' = $true;  &#xD;&#xA;        'Windows Error Reporting System Queue Files' = $true;  &#xD;&#xA;        'Windows Upgrade Log Files' = $true;  &#xD;&#xA;    } &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#endregion Settings&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#region functions&#xD;&#xA;&#xD;&#xA;function Test-IsAdmin {&#xD;&#xA;    $currentUser = [Security.Principal.WindowsIdentity]::GetCurrent()&#xD;&#xA;&#xD;&#xA;    (New-Object Security.Principal.WindowsPrincipal $currentUser).IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;function Test-RegSubKey&#xD;&#xA;{&#xD;&#xA;# Function: Test-RegSubKey&#xD;&#xA;# Description: Test the existence of the registry key&#xD;&#xA;# Return Value: True/false respectively&#xD;&#xA;&#x9;param(&#xD;&#xA;&#x9;&#x9;[string]$ComputerName = &quot;.&quot;,&#xD;&#xA;&#x9;&#x9;[string]$hive,&#xD;&#xA;&#x9;&#x9;[string]$keyName&#xD;&#xA;&#x9;)&#xD;&#xA;&#xD;&#xA;&#x9;$hives = [enum]::getnames([Microsoft.Win32.RegistryHive])&#xD;&#xA;&#xD;&#xA;&#x9;if($hives -notcontains $hive){&#xD;&#xA;&#x9;&#x9;write-error &quot;Invalid hive value&quot;;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;$regHive = [Microsoft.Win32.RegistryHive]$hive;&#xD;&#xA;&#x9;$regKey = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey($regHive,$ComputerName);&#xD;&#xA;&#x9;$subKey = $regKey.OpenSubKey($keyName);&#xD;&#xA;&#xD;&#xA;&#x9;if(!$subKey){$false}  else {$true}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;function New-RegSubKey&#xD;&#xA;{&#xD;&#xA;# Function: New-RegSubKey&#xD;&#xA;# Description: Create the registry key&#xD;&#xA;# Return Value: True/false respectively&#xD;&#xA;&#xD;&#xA;&#x9;param(&#xD;&#xA;&#x9;&#x9;[string]$ComputerName = &quot;.&quot;,&#xD;&#xA;&#x9;&#x9;[string]$hive,&#xD;&#xA;&#x9;&#x9;[string]$keyName&#xD;&#xA;&#x9;)&#xD;&#xA;&#xD;&#xA;&#x9;$hives = [enum]::getnames([Microsoft.Win32.RegistryHive])&#xD;&#xA;&#xD;&#xA;&#x9;if($hives -notcontains $hive){&#xD;&#xA;&#x9;&#x9;write-error &quot;Invalid hive value&quot;;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;$regHive = [Microsoft.Win32.RegistryHive]$hive;&#xD;&#xA;&#x9;$regKey = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey($regHive,$ComputerName);&#xD;&#xA;&#x9;[void]$regKey.CreateSubKey($keyName);&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;if($?) {$true} else {$false}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;function Test-RegValue&#xD;&#xA;{&#xD;&#xA;# Function: Test-RegValue&#xD;&#xA;# Description: Test the existence of the registry value&#xD;&#xA;# Return Value: True/false respectively&#xD;&#xA;&#x9;param(&#xD;&#xA;&#x9;&#x9;[string]$ComputerName = $env:COMPUTERNAME,&#xD;&#xA;&#x9;&#x9;[string]$hive,&#xD;&#xA;&#x9;&#x9;[string]$keyName,&#xD;&#xA;&#x9;&#x9;[string]$valueName&#xD;&#xA;&#x9;)&#xD;&#xA;&#xD;&#xA;&#x9;$hives = [enum]::getnames([Microsoft.Win32.RegistryHive])&#xD;&#xA;&#xD;&#xA;&#x9;if($hives -notcontains $hive)&#xD;&#xA;    {&#xD;&#xA;&#x9;&#x9;write-error &quot;Invalid hive value&quot;;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;$regHive = [Microsoft.Win32.RegistryHive]$hive;&#xD;&#xA;&#x9;$regKey = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey($regHive,$ComputerName);&#xD;&#xA;&#x9;$subKey = $regKey.OpenSubKey($keyName);&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;if(!$subKey)&#xD;&#xA;    {&#xD;&#xA;&#x9;&#x9;write-error &quot;The specified registry key does not exist.&quot;;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;$regVal=$subKey.GetValue($valueName);&#xD;&#xA;&#x9;if(!$regVal){$false} else {$true}&#xD;&#xA;}#end function Test-RegValue&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;function Set-RegDefault&#xD;&#xA;{&#xD;&#xA;# Function: Set-RegDefault&#xD;&#xA;# Description: Set the registry default value&#xD;&#xA;# Return Value: True/false respectively&#xD;&#xA;&#xD;&#xA;&#x9;param(&#xD;&#xA;&#x9;&#x9;[string]$ComputerName = &quot;.&quot;,&#xD;&#xA;&#x9;&#x9;[string]$hive,&#xD;&#xA;&#x9;&#x9;[string]$keyName,&#xD;&#xA;        [ValidateSet('String','ExpandString','DWord')]&#xD;&#xA;        [string]$Type,&#xD;&#xA;&#x9;&#x9;$value&#x9;&#xD;&#xA;&#x9;)&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;$hives = [enum]::getnames([Microsoft.Win32.RegistryHive])&#xD;&#xA;&#xD;&#xA;&#x9;if($hives -notcontains $hive){&#xD;&#xA;&#x9;&#x9;write-error &quot;Invalid hive value&quot;;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;$regHive = [Microsoft.Win32.RegistryHive]$hive;&#xD;&#xA;&#x9;$regKey = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey($regHive,$ComputerName);&#xD;&#xA;&#x9;$subKey = $regKey.OpenSubKey($keyName,$true);&#xD;&#xA;&#xD;&#xA;&#x9;if(!$subKey){&#xD;&#xA;&#x9;&#x9;write-error &quot;The specified registry key does not exist.&quot;;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;    Switch ($Type)&#xD;&#xA;    {&#xD;&#xA;&#x9;    'String' {#$regKey.SetValue($null, $value,[Microsoft.Win32.RegistryValueKind]::String);&#xD;&#xA;&#x9;            $subKey.SetValue($null, $value,[Microsoft.Win32.RegistryValueKind]::String);}&#xD;&#xA;&#xD;&#xA;        'ExpandString' { $subKey.SetValue($null, $value,[Microsoft.Win32.RegistryValueKind]::ExpandString); }&#xD;&#xA;&#xD;&#xA;        'DWord' { $subKey.SetValue($null, $value,[Microsoft.Win32.RegistryValueKind]::DWord); }&#xD;&#xA;    &#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;if($?) {$true} else {$false}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;function Set-RegString&#xD;&#xA;{&#xD;&#xA;# Function: Set-RegString&#xD;&#xA;# Description: Create/Update the specified registry string value&#xD;&#xA;# Return Value: True/false respectively&#xD;&#xA;&#x9;param(&#xD;&#xA;&#x9;&#x9;[string]$ComputerName = &quot;.&quot;,&#xD;&#xA;&#x9;&#x9;[string]$hive,&#xD;&#xA;&#x9;&#x9;[string]$keyName,&#xD;&#xA;&#x9;&#x9;[string]$valueName,&#xD;&#xA;&#x9;&#x9;[string]$value&#x9;&#xD;&#xA;&#x9;)&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;$hives = [enum]::getnames([Microsoft.Win32.RegistryHive])&#xD;&#xA;&#xD;&#xA;&#x9;if($hives -notcontains $hive){&#xD;&#xA;&#x9;&#x9;write-error &quot;Invalid hive value&quot;;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;$regHive = [Microsoft.Win32.RegistryHive]$hive;&#xD;&#xA;&#x9;$regKey = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey($regHive,$ComputerName);&#xD;&#xA;&#x9;$subKey = $regKey.OpenSubKey($keyName,$true);&#xD;&#xA;&#xD;&#xA;&#x9;if(!$subKey){&#xD;&#xA;&#x9;&#x9;write-error &quot;The specified registry key does not exist.&quot;;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;$subKey.SetValue($valueName, $value, [Microsoft.Win32.RegistryValueKind]::String);&#xD;&#xA;&#x9;if($?) {$true} else {$false}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;function Set-RegDWord&#xD;&#xA;{&#xD;&#xA;# Function: Set-RegDWord&#xD;&#xA;# Description: Create/Update the registry value (REG_DWORD)&#xD;&#xA;# Return Value: True/false respectively&#xD;&#xA;&#x9;param(&#xD;&#xA;&#x9;&#x9;[string]$ComputerName = $env:COMPUTERNAME,&#xD;&#xA;&#x9;&#x9;[string]$hive,&#xD;&#xA;&#x9;&#x9;[string]$keyName,&#xD;&#xA;&#x9;&#x9;[string]$valueName,&#xD;&#xA;&#x9;&#x9;[double]$value&#x9;&#xD;&#xA;&#x9;)&#xD;&#xA;&#xD;&#xA;&#x9;$hives = [enum]::getnames([Microsoft.Win32.RegistryHive])&#xD;&#xA;&#xD;&#xA;&#x9;if($hives -notcontains $hive)&#xD;&#xA;    {&#xD;&#xA;&#x9;&#x9;write-error &quot;Invalid hive value&quot;;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;$regHive = [Microsoft.Win32.RegistryHive]$hive;&#xD;&#xA;&#x9;$regKey = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey($regHive,$ComputerName);&#xD;&#xA;&#x9;$subKey = $regKey.OpenSubKey($keyName,$true);&#xD;&#xA;&#xD;&#xA;&#x9;if(!$subKey){&#xD;&#xA;&#x9;&#x9;write-error &quot;The specified registry key does not exist.&quot;;&#xD;&#xA;&#x9;&#x9;return;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;$subKey.SetValue($valueName, $value,[Microsoft.Win32.RegistryValueKind]::DWord);&#xD;&#xA;&#x9;if($?) {$true} else {$false}&#xD;&#xA;}#end function Set-RegDWord&#xD;&#xA;&#xD;&#xA;#endregion functions&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;} # end BEGIN&#xD;&#xA;&#xD;&#xA;PROCESS {&#xD;&#xA;&#xD;&#xA;    If (-not (Test-IsAdmin)) { Write-Warning &quot;This script requires Admin rights.&quot; ; return}&#xD;&#xA;&#xD;&#xA;    IF (Test-Connection -ComputerName $ComputerName -count 2 -quiet) &#xD;&#xA;    {    &#xD;&#xA;        Try&#xD;&#xA;        {    &#xD;&#xA;            # ensure we're running on Windows Server 2008R2 &#xD;&#xA;            $OS = Get-WmiObject -Class Win32_OperatingSystem -ComputerName $ComputerName -Property Version, ProductType, OSLanguage -ErrorAction Stop&#xD;&#xA;            If (($OS.Version -like '6.1*') -and ($OS.ProductType -eq 3))&#xD;&#xA;            {&#xD;&#xA;                Write-Verbose &quot;Windows Server 2008R2 detected&quot; -Verbose&#xD;&#xA;                Try{Get-HotFix -ComputerName $ComputerName -Id kb2852386 -ErrorAction Stop | Out-Null}&#xD;&#xA;                Catch {Write-Warning &quot;KB2852386 is required. Please install hotfix and re-run.&quot;;return}&#xD;&#xA;&#xD;&#xA;                Switch ($OS.OSLanguage)&#xD;&#xA;                {&#xD;&#xA;                    '1031' { Write-Verbose &quot;OS = German&quot;&#xD;&#xA;             &#xD;&#xA;                            Copy-Item &quot;\\$ComputerName\C$\Windows\winsxs\amd64_microsoft-windows-cleanmgr_31bf3856ad364e35_6.1.7600.16385_none_c9392808773cd7da\cleanmgr.exe&quot; &quot;\\$ComputerName\C$\Windows\system32&quot; -ErrorAction Stop&#xD;&#xA;                            Copy-Item &quot;\\$ComputerName\C$\Windows\winsxs\amd64_microsoft-windows-cleanmgr.resources_31bf3856ad364e35_6.1.7600.16385_de-de_10da8b9bc379c09e\cleanmgr.exe.mui&quot; &quot;\\$ComputerName\C$\Windows\System32\de-DE&quot; -ErrorAction Stop&#xD;&#xA;&#xD;&#xA;                            Copy-Item &quot;\\$ComputerName\C$\Windows\winsxs\amd64_microsoft-windows-dataclen_31bf3856ad364e35_6.1.7600.16385_none_529b2718ad26c095\dataclen.dll&quot; &quot;\\$ComputerName\C$\Windows\system32&quot; -ErrorAction Stop&#xD;&#xA;                            Copy-Item &quot;\\$ComputerName\C$\Windows\winsxs\amd64_microsoft-windows-dataclen.resources_31bf3856ad364e35_6.1.7600.16385_de-de_704bd9d247dc15d7\dataclen.dll.mui&quot; &quot;\\$ComputerName\C$\Windows\System32\de-DE&quot; -ErrorAction Stop&#xD;&#xA;                        }&#xD;&#xA;                    '1033' { Write-Verbose &quot;OS = English_US&quot;&#xD;&#xA;    &#xD;&#xA;                            Copy-Item &quot;\\$ComputerName\C$\Windows\winsxs\amd64_microsoft-windows-cleanmgr_31bf3856ad364e35_6.1.7600.16385_none_c9392808773cd7da\cleanmgr.exe&quot; &quot;\\$ComputerName\C$\Windows\system32&quot; -ErrorAction Stop&#xD;&#xA;                            Copy-Item &quot;\\$ComputerName\C$\Windows\winsxs\amd64_microsoft-windows-cleanmgr.resources_31bf3856ad364e35_6.1.7600.16385_en-us_b9cb6194b257cc63\cleanmgr.exe.mui&quot; &quot;\\$ComputerName\C$\Windows\System32\en-US&quot; -ErrorAction Stop&#xD;&#xA;&#xD;&#xA;                            Copy-Item &quot;\\$ComputerName\c$\windows\winsxs\amd64_microsoft-windows-dataclen_31bf3856ad364e35_6.1.7600.16385_none_529b2718ad26c095\dataclen.dll&quot; &quot;\\$ComputerName\C$\Windows\system32&quot; -ErrorAction Stop&#xD;&#xA;                            Copy-Item &quot;\\$ComputerName\c$\windows\winsxs\amd64_microsoft-windows-dataclen.resources_31bf3856ad364e35_6.1.7600.16385_en-us_193cafcb36ba219c\dataclen.dll.mui&quot; &quot;\\$ComputerName\C$\Windows\System32\en-US&quot; -ErrorAction Stop&#xD;&#xA;                         }&#xD;&#xA;                    Default { Write-Warning &quot;OS Language [$($OS.OSLanguage)] not Supported for this Script&quot;; return }&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;            }&#xD;&#xA;            Else&#xD;&#xA;            {&#xD;&#xA;                Write-Warning &quot;This script is for Windows Server 2008R2 only&quot;&#xD;&#xA;                return&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            ($TempFolders.GetEnumerator() | Sort-Object Name) | Out-String | Write-Verbose &#xD;&#xA;&#xD;&#xA;#region Reg_CLSID&#xD;&#xA;            # save the current Setting&#xD;&#xA;            $DefaultErrorActionPreference = $ErrorActionPreference.ToString()&#xD;&#xA;            $ErrorActionPreference = 'Stop'  &#xD;&#xA;             &#xD;&#xA;            # create Registry CLSID structure for Disk Cleanup Manager&#xD;&#xA;            If (-not (Test-RegSubKey -ComputerName $ComputerName -hive 'ClassesRoot' -keyName 'CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}'))&#xD;&#xA;            {&#xD;&#xA;&#xD;&#xA;                Write-Verbose &quot;Creating RegKey \\$ComputerName\HKEY_CLASSES_ROOT\CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6} ...&quot;&#xD;&#xA;                New-RegSubKey -ComputerName $ComputerName -hive 'ClassesRoot' -keyName 'CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}'&#xD;&#xA;&#xD;&#xA;                Write-Verbose &quot;Creating RegKey \\$ComputerName\HKEY_CLASSES_ROOT\CLSID\{C1060E7E-7939-44A5-99C3-A6DCCD92AED0}\InProcServer32 ...&quot;&#xD;&#xA;                New-RegSubKey -ComputerName $ComputerName -hive 'ClassesRoot' -keyName 'CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}\InProcServer32'&#xD;&#xA;&#xD;&#xA;                Write-Verbose &quot;Creating Default RegValue at \\$ComputerName\HKEY_CLASSES_ROOT\CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6} ...&quot;&#xD;&#xA;                # Reg_SZ&#xD;&#xA;                Set-RegDefault -ComputerName $ComputerName -hive 'ClassesRoot' -keyName 'CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}' -Type String -value 'Data Driven Cleaner' &#xD;&#xA;&#xD;&#xA;                Write-Verbose &quot;Creating Default RegValue at \\$ComputerName\HKEY_CLASSES_ROOT\CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}\InProcServer32 ...&quot;&#xD;&#xA;                # Reg_EXPAND_SZ&#xD;&#xA;                Set-RegDefault -ComputerName $ComputerName -hive 'ClassesRoot' -keyName 'CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}\InProcServer32' -Type ExpandString -value '%SystemRoot%\System32\DATACLEN.DLL' &#xD;&#xA;&#xD;&#xA;                 Write-Verbose &quot;Creating 'Apartment' RegValue at \\$ComputerName\HKEY_CLASSES_ROOT\CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}\InProcServer32 ...&quot;&#xD;&#xA;                # Reg_SZ&#xD;&#xA;                Set-RegString -ComputerName $ComputerName -hive 'ClassesRoot' -keyName 'CLSID\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}\InProcServer32' -valueName 'ThreadingModel' -value 'Apartment'&#xD;&#xA;&#xD;&#xA;            }&#xD;&#xA;            # Reset to Default&#xD;&#xA;            $ErrorActionPreference = $DefaultErrorActionPreference &#xD;&#xA;#endregion Reg_CLSID&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#region Reg_StateFlags&#xD;&#xA;            #Set StateFlags setting for each item of disk cleanup utility&#xD;&#xA;            foreach ($TemFolder in ($TempFolders.GetEnumerator() | Sort-Object Name).Key)&#xD;&#xA;            {&#xD;&#xA;                $RegKey = $RegPath + &quot;\&quot; + $TemFolder&#xD;&#xA;                &#xD;&#xA;                If ($TempFolders.$TemFolder)&#xD;&#xA;                {&#xD;&#xA;                    #Include this handler when this profile is run.&#xD;&#xA;                    If (-Not (Set-RegDWord -ComputerName $ComputerName -hive $RegHive -keyName $RegKey -valueName $RegValueName -value 2))&#xD;&#xA;                    {&#xD;&#xA;                        Write-Error &quot;Could not set RegValue \\$ComputerName\$RegHive\$RegKey\$RegValueName&quot;&#xD;&#xA;                        return&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;                Else&#xD;&#xA;                {&#xD;&#xA;                    # Do not run this handler when this profile is run.&#xD;&#xA;                    If (-Not (Set-RegDWord -ComputerName $ComputerName -hive $RegHive -keyName $RegKey -valueName $RegValueName -value 0))&#xD;&#xA;                    {&#xD;&#xA;                        Write-Error &quot;Could not set RegValue \\$ComputerName\$RegHive\$RegKey\$RegValueName&quot;&#xD;&#xA;                        return&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;             } #end foreach ($TemFolder in $TempFolders)&#xD;&#xA;#endregion Reg_StateFlags&#xD;&#xA;&#xD;&#xA;            #Capture current free disk space on Drive C:&#xD;&#xA;            $FreespaceBefore = (Get-WmiObject -Class win32_logicaldisk -ComputerName $ComputerName -filter &quot;DeviceID='C:'&quot; | select Freespace).FreeSpace/1GB&#xD;&#xA;&#xD;&#xA;    &#xD;&#xA;            # Invoke cleanmgr.exe on local or remote Computer&#xD;&#xA;            $WMIParam = @{&#xD;&#xA;                Path = 'Win32_Process';&#xD;&#xA;                ComputerName = $ComputerName;&#x9;&#xD;&#xA;                Name = 'Create';&#xD;&#xA;                ArgumentList = 'cleanmgr.exe /sagerun:32'; &#xD;&#xA;            }&#xD;&#xA;            Try &#xD;&#xA;            {&#xD;&#xA;                Invoke-WmiMethod @WMIParam -ErrorAction Stop | Out-Null&#xD;&#xA;            } &#xD;&#xA;            Catch &#xD;&#xA;            {&#xD;&#xA;                Write-Warning (&quot;{0}: {1}&quot; -f $ComputerName,$_.Exception.Message)&#xD;&#xA;                return&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            do &#xD;&#xA;            {&#xD;&#xA;                Write-Host &quot;waiting for cleanmgr to complete. . .&quot;&#xD;&#xA;                start-sleep 5&#xD;&#xA;            } while ((Get-WmiObject -Class win32_process -ComputerName $ComputerName | Where-Object {$_.processname -eq 'cleanmgr.exe'} | measure).count)&#xD;&#xA;&#xD;&#xA;            #Capture free disk space after cleanmgr on Drive C:&#xD;&#xA;            $FreespaceAfter = (Get-WmiObject -Class win32_logicaldisk -ComputerName $ComputerName -filter &quot;DeviceID='C:'&quot; | select Freespace).FreeSpace/1GB&#xD;&#xA;&#xD;&#xA;            Write-Host &quot; &quot;    &#xD;&#xA;            &quot;Free Space in GB Before: {0:N3}&quot; -f $FreespaceBefore&#xD;&#xA;            &quot;Free Space in GB After : {0:N3}&quot; -f $FreespaceAfter                &#xD;&#xA;    &#xD;&#xA;            Write-Host  &quot;Disk Cleanup was successfully&quot; -ForegroundColor Green &#xD;&#xA;&#xD;&#xA;         }&#xD;&#xA;         Catch&#xD;&#xA;         {&#xD;&#xA;            Write-Error (&quot;{0}: {1}&quot; -f $ComputerName,$_.Exception.Message)&#xD;&#xA;         }   &#xD;&#xA;&#xD;&#xA;    } &#xD;&#xA;    Else &#xD;&#xA;    {&#xD;&#xA;        Write-Warning &quot;\\$ComputerName DO NOT reply to ping&quot; &#xD;&#xA;    } # end IF (Test-Connection -ComputerName $ComputerName -count 2 -quiet)    &#xD;&#xA;&#xD;&#xA;} # end PROCESS&#xD;&#xA;&#xD;&#xA;END { Write-Verbose &quot;Function ${CmdletName} finished.&quot; }&#xD;&#xA;&#xD;&#xA;} # end Function Invoke-LHSDiskCleanup      &#xD;&#xA;             &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
</CodeSnippets>