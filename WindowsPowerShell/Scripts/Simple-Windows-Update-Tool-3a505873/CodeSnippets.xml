<?xml version="1.0" encoding="utf-8"?>
<CodeSnippets>
  <Code Content="&lt;#&#xD;&#xA;    .SYNOPSIS&#xD;&#xA;&#x9;&#x9;Powershell Script to Install Updates Based on the Type of update&#xD;&#xA;&#x9;.DESCRIPTION&#xD;&#xA;        Using the WIndows Update API, Each update has a specific Root category. By selecting with Type of Update you want, you can avoid installing unwanted updates&#xD;&#xA;&#x9;.PARAMETER Path&#xD;&#xA;&#x9;&#x9;The full path AND name where the script is located.&#xD;&#xA;&#x9;.PARAMETER Reboot&#xD;&#xA;        If a reboot is required for an update, the system will restart.&#xD;&#xA;&#x9;.PARAMETER ScanOnly&#xD;&#xA;&#x9;&#x9;As implies, It does not download or install updates, just lists the available ones based on criteria &#xD;&#xA;&#x9;.PARAMETER ProxyAddress&#xD;&#xA;        *THIS PARAMETER IS STILL BETA!!!* Instead of using the default windows update API, use another endpoint for updates. &#xD;&#xA;    .PARAMETER UpdateTypes&#xD;&#xA;        RootCategories that are associated with windows updates. Choose the types you wish to filter for. &#xD;&#xA;    .EXAMPLE&#xD;&#xA;&#x9;&#x9;    &amp; '.\Invoke-WindowsUpdates.ps1' -Reboot -UpdateTypes Definition, Critical, Security -Path '.\Invoke-WindowsUpdates.ps1'&#xD;&#xA;    .Notes&#xD;&#xA;        Author: Leotus Richard&#xD;&#xA;        website: http://outboxedsolutions.azurewebsites.net/&#xD;&#xA;&#xD;&#xA;        Version History&#xD;&#xA;        1.0.0  3/24/2014&#xD;&#xA;            - Initial Release&#xD;&#xA;&#xD;&#xA;        1.0.1  3/25/2014&#xD;&#xA;            - Adjusted script, SCANONLY is default $true to prevent accidental windows installation. &#xD;&#xA;            - Added a &quot;ShowCategories&quot; Switch to view the types of updates.  &#xD;&#xA;&#xD;&#xA;        Upcoming Features&#xD;&#xA;            - Report generator&#xD;&#xA;            - email functionality&#xD;&#xA;            - Improve WSUS/Proxy functionality *BETA*&#xD;&#xA;            - Add a function determine installation status &#xD;&#xA;#&gt;&#xD;&#xA;[CmdletBinding()]&#xD;&#xA;param(&#xD;&#xA;$Path = (Get-Location),&#xD;&#xA;[switch]$Reboot, &#xD;&#xA;[switch]$ScanOnly = $true, &#xD;&#xA;[string]$ProxyAddress,&#xD;&#xA;[switch]$ShowCategories,&#xD;&#xA;[String[]][ValidateSet(&quot;Critical&quot;,&quot;Definition&quot;, &quot;Drivers&quot;, &quot;FeaturePacks&quot;, &quot;Security&quot;, &quot;ServicePacks&quot;, &quot;Tools&quot;, &quot;UpdateRollups&quot;, &quot;Updates&quot;, &quot;Microsoft&quot;, &quot;ALL&quot;)]$UpdateTypes = &quot;ALL&quot;&#xD;&#xA;&#xD;&#xA;)&#xD;&#xA;    $AvailableUpdates = @()&#xD;&#xA;    $UpdateIds = @()&#xD;&#xA;    $UpdateTypes&#xD;&#xA;&#xD;&#xA;    Write-Host &quot;Checking for elevation... &quot; -NoNewline&#xD;&#xA;    $CurrentUser = New-Object Security.Principal.WindowsPrincipal $([Security.Principal.WindowsIdentity]::GetCurrent())&#xD;&#xA;    if (($CurrentUser.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)) -eq $false){&#xD;&#xA;        $ArgumentList = &quot;-noprofile -noexit -file `&quot;{0}`&quot; -Path `&quot;$Path`&quot;&quot;&#xD;&#xA;        If ($ScanOnly) {$ArgumentList = $ArgumentList + &quot; -ScanOnly&quot;}&#xD;&#xA;        If ($reboot) {$ArgumentList = $ArgumentList + &quot; -Reboot&quot;}&#xD;&#xA;        If ($ProxyAddress){$ArgumentList = $ArgumentList + &quot; -ProxyAddress $ProxyAddress&quot;}&#xD;&#xA;        If ($ShowCategories) {$ArgumentList = $ArgumentList + &quot; -ShowCategories&quot;}&#xD;&#xA;        If ($UpdateTypes) {$ArgumentList = $ArgumentList + &quot; -UpdateTypes $UpdateTypes&quot;}&#xD;&#xA;&#xD;&#xA;    Write-Host &quot;elevating&quot;&#xD;&#xA;    Start-Process powershell.exe -Verb RunAs -ArgumentList ($ArgumentList -f ($myinvocation.MyCommand.Definition))&#xD;&#xA;&#xD;&#xA;    Write-Host &quot;Exiting, please refer to console window&quot; -ForegroundColor DarkRed&#xD;&#xA;        break&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;    if ($Reboot) {&#xD;&#xA;        Write-Host &quot;The computer will reboot if needed after installation is complete.&quot;&#xD;&#xA;        Write-Host&#xD;&#xA;    }&#xD;&#xA;    if ($ScanOnly) {&#xD;&#xA;        Write-Host &quot;Running in scan only mode.&quot;&#xD;&#xA;        Write-Host&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    Write-Verbose &quot;Creating Update Session&quot;&#xD;&#xA;    $Session = New-Object -com &quot;Microsoft.Update.Session&quot;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    if ($ProxyAddress -ne $null) {&#xD;&#xA;    Write-Verbose &quot;Setting Proxy&quot;&#xD;&#xA;        $Proxy = New-Object -com &quot;Microsoft.Update.WebProxy&quot;&#xD;&#xA;        $Session.WebProxy.Address = $Proxyaddress&#xD;&#xA;        $Session.WebProxy.AutoDetect = $FALSE&#xD;&#xA;        $Session.WebProxy.BypassProxyOnLocal = $TRUE&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    Write-Verbose &quot;Creating Update Type Array&quot;&#xD;&#xA;    foreach($UpdateType in $UpdateTypes)&#xD;&#xA;    {&#xD;&#xA;        $UpdateID&#xD;&#xA;        switch ($UpdateType)&#xD;&#xA;        {&#xD;&#xA;        &quot;Critical&quot; {$UpdateID = 0}&#xD;&#xA;        &quot;Definition&quot;{$UpdateID = 1}&#xD;&#xA;        &quot;Drivers&quot;{$UpdateID = 2}&#xD;&#xA;        &quot;FeaturePacks&quot;{$UpdateID = 3}&#xD;&#xA;        &quot;Security&quot;{$UpdateID = 4}&#xD;&#xA;        &quot;ServicePacks&quot;{$UpdateID = 5}&#xD;&#xA;        &quot;Tools&quot;{$UpdateID = 6}&#xD;&#xA;        &quot;UpdateRollups&quot;{$UpdateID = 7}&#xD;&#xA;        &quot;Updates&quot;{$UpdateID = 8}&#xD;&#xA;        &quot;Microsoft&quot;{$UpdateID = 9}&#xD;&#xA;        default {$UpdateID=99}&#xD;&#xA;        }&#xD;&#xA;        $UpdateIds += $UpdateID&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    Write-Host &quot;Searching for updates...&quot;&#xD;&#xA;    $Search = $Session.CreateUpdateSearcher()&#xD;&#xA;    $SearchResults = $Search.Search(&quot;IsInstalled=0 and IsHidden=0&quot;)&#xD;&#xA;    Write-Host &quot;There are &quot; $SearchResults.Updates.Count &quot;TOTAL updates available.&quot;&#xD;&#xA;&#xD;&#xA;    if($UpdateIds -eq 99)&#xD;&#xA;    {&#xD;&#xA;        $AvailableUpdates = $SearchResults.Updates&#xD;&#xA;    }&#xD;&#xA;    else{&#xD;&#xA;        &#xD;&#xA;        foreach($UpdateID in $UpdateIds)&#xD;&#xA;        {&#xD;&#xA;            $AvailableUpdates += $SearchResults.RootCategories.Item($UpdateID).Updates&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    Write-Host &quot;Updates selected for installation&quot;&#xD;&#xA;    $AvailableUpdates | ForEach-Object {&#xD;&#xA;    &#xD;&#xA;        if (($_.InstallationBehavior.CanRequestUserInput) -or ($_.EulaAccepted -eq $FALSE)) {&#xD;&#xA;            Write-Host $_.Title &quot; *** Requires user input and will not be installed.&quot; -ForegroundColor Yellow&#xD;&#xA;            if($ShowCategories)&#xD;&#xA;            {&#xD;&#xA;                $_.Categories | ForEach-Object {Write-Host &quot;     &quot;$_.Name.ToString() -ForegroundColor Cyan}&#xD;&#xA;                &#xD;&#xA;            }&#xD;&#xA;                &#xD;&#xA;        }&#xD;&#xA;        else {&#xD;&#xA;            Write-Host $_.Title -ForegroundColor Green&#xD;&#xA;            if($ShowCategories)&#xD;&#xA;            {&#xD;&#xA;                $_.Categories | ForEach-Object {Write-Host &quot;     &quot;$_.Name.ToString() -ForegroundColor Cyan}&#xD;&#xA;                &#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    # Exit script if no updates are available&#xD;&#xA;    if ($ScanOnly) {&#xD;&#xA;        Write-Host &quot;Exiting...&quot;;&#xD;&#xA;        break&#xD;&#xA;    }&#xD;&#xA;    if($AvailableUpdates.count -lt 1){&#xD;&#xA;        Write-Host &quot;No results meet your criteria. Exiting&quot;;&#xD;&#xA;        break&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    Write-Verbose &quot;Creating Download Selection&quot;&#xD;&#xA;    $DownloadCollection = New-Object -com &quot;Microsoft.Update.UpdateColl&quot;&#xD;&#xA;&#xD;&#xA;    $AvailableUpdates | ForEach-Object {&#xD;&#xA;        if ($_.InstallationBehavior.CanRequestUserInput -ne $TRUE) {&#xD;&#xA;            $DownloadCollection.Add($_) | Out-Null&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;    Write-Verbose &quot;Downloading Updates&quot;&#xD;&#xA;    Write-Host &quot;Downloading updates...&quot;&#xD;&#xA;    $Downloader = $Session.CreateUpdateDownloader()&#xD;&#xA;    $Downloader.Updates = $DownloadCollection&#xD;&#xA;    $Downloader.Download()&#xD;&#xA;&#xD;&#xA;    Write-Host &quot;Download complete.&quot;&#xD;&#xA;&#xD;&#xA;    Write-Verbose &quot;Creating Installation Object&quot;&#xD;&#xA;    $InstallCollection = New-Object -com &quot;Microsoft.Update.UpdateColl&quot;&#xD;&#xA;    $AvailableUpdates | ForEach-Object {&#xD;&#xA;&#x9;    if ($_.IsDownloaded) {&#xD;&#xA;&#x9;&#x9;    $InstallCollection.Add($_) | Out-Null&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    Write-Verbose &quot;Installing Updates&quot;&#xD;&#xA;    Write-Host &quot;Installing updates...&quot;&#xD;&#xA;    $Installer = $Session.CreateUpdateInstaller()&#xD;&#xA;    $Installer.Updates = $InstallCollection&#xD;&#xA;    $Results = $Installer.Install()&#xD;&#xA;    Write-Host &quot;Installation complete.&quot;&#xD;&#xA;    Write-Host&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    # Reboot if needed&#xD;&#xA;    if ($Results.RebootRequired) {&#xD;&#xA;        if ($Reboot) {&#xD;&#xA;            Write-Host &quot;Rebooting...&quot;&#xD;&#xA;            Restart-Computer ## add computername here&#xD;&#xA;        }&#xD;&#xA;        else {&#xD;&#xA;&#x9;        Write-Host &quot;Please reboot.&quot;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    else {&#xD;&#xA;&#x9;    Write-Host &quot;No reboot required.&quot;&#xD;&#xA;    }" />
  <Code Content="&lt;#&#xD;&#xA;    .SYNOPSIS&#xD;&#xA;&#x9;&#x9;Powershell Script to Install Updates Based on the Type of update&#xD;&#xA;&#x9;.DESCRIPTION&#xD;&#xA;        Using the WIndows Update API, Each update has a specific Root category. By selecting with Type of Update you want, you can avoid installing unwanted updates&#xD;&#xA;&#x9;.PARAMETER Path&#xD;&#xA;&#x9;&#x9;The full path AND name where the script is located.&#xD;&#xA;&#x9;.PARAMETER Reboot&#xD;&#xA;        If a reboot is required for an update, the system will restart.&#xD;&#xA;&#x9;.PARAMETER ScanOnly&#xD;&#xA;&#x9;&#x9;As implies, It does not download or install updates, just lists the available ones based on criteria &#xD;&#xA;&#x9;.PARAMETER ProxyAddress&#xD;&#xA;        *THIS PARAMETER IS STILL BETA!!!* Instead of using the default windows update API, use another endpoint for updates. &#xD;&#xA;    .PARAMETER UpdateTypes&#xD;&#xA;        RootCategories that are associated with windows updates. Choose the types you wish to filter for. &#xD;&#xA;    .EXAMPLE&#xD;&#xA;&#x9;&#x9;    &amp; '.\Invoke-WindowsUpdates.ps1' -Reboot -UpdateTypes Definition, Critical, Security -Path '.\Invoke-WindowsUpdates.ps1'&#xD;&#xA;    .Notes&#xD;&#xA;        Author: Leotus Richard&#xD;&#xA;        website: http://outboxedsolutions.azurewebsites.net/&#xD;&#xA;&#xD;&#xA;        Version History&#xD;&#xA;        1.0.0  3/24/2014&#xD;&#xA;            - Initial Release&#xD;&#xA;&#xD;&#xA;        1.0.1  3/25/2014&#xD;&#xA;            - Adjusted script, SCANONLY is default $true to prevent accidental windows installation. &#xD;&#xA;            - Added a &quot;ShowCategories&quot; Switch to view the types of updates.  &#xD;&#xA;&#xD;&#xA;        Upcoming Features&#xD;&#xA;            - Report generator&#xD;&#xA;            - email functionality&#xD;&#xA;            - Improve WSUS/Proxy functionality *BETA*&#xD;&#xA;            - Add a function determine installation status &#xD;&#xA;#&gt;&#xD;&#xA;[CmdletBinding()]&#xD;&#xA;param(&#xD;&#xA;$Path = (Get-Location),&#xD;&#xA;[switch]$Reboot, &#xD;&#xA;[switch]$ScanOnly = $true, &#xD;&#xA;[string]$ProxyAddress,&#xD;&#xA;[switch]$ShowCategories,&#xD;&#xA;[String[]][ValidateSet(&quot;Critical&quot;,&quot;Definition&quot;, &quot;Drivers&quot;, &quot;FeaturePacks&quot;, &quot;Security&quot;, &quot;ServicePacks&quot;, &quot;Tools&quot;, &quot;UpdateRollups&quot;, &quot;Updates&quot;, &quot;Microsoft&quot;, &quot;ALL&quot;)]$UpdateTypes = &quot;ALL&quot;&#xD;&#xA;&#xD;&#xA;)&#xD;&#xA;    $AvailableUpdates = @()&#xD;&#xA;    $UpdateIds = @()&#xD;&#xA;    $UpdateTypes&#xD;&#xA;&#xD;&#xA;    Write-Host &quot;Checking for elevation... &quot; -NoNewline&#xD;&#xA;    $CurrentUser = New-Object Security.Principal.WindowsPrincipal $([Security.Principal.WindowsIdentity]::GetCurrent())&#xD;&#xA;    if (($CurrentUser.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)) -eq $false){&#xD;&#xA;        $ArgumentList = &quot;-noprofile -noexit -file `&quot;{0}`&quot; -Path `&quot;$Path`&quot;&quot;&#xD;&#xA;        If ($ScanOnly) {$ArgumentList = $ArgumentList + &quot; -ScanOnly&quot;}&#xD;&#xA;        If ($reboot) {$ArgumentList = $ArgumentList + &quot; -Reboot&quot;}&#xD;&#xA;        If ($ProxyAddress){$ArgumentList = $ArgumentList + &quot; -ProxyAddress $ProxyAddress&quot;}&#xD;&#xA;        If ($ShowCategories) {$ArgumentList = $ArgumentList + &quot; -ShowCategories&quot;}&#xD;&#xA;        If ($UpdateTypes) {$ArgumentList = $ArgumentList + &quot; -UpdateTypes $UpdateTypes&quot;}&#xD;&#xA;&#xD;&#xA;    Write-Host &quot;elevating&quot;&#xD;&#xA;    Start-Process powershell.exe -Verb RunAs -ArgumentList ($ArgumentList -f ($myinvocation.MyCommand.Definition))&#xD;&#xA;&#xD;&#xA;    Write-Host &quot;Exiting, please refer to console window&quot; -ForegroundColor DarkRed&#xD;&#xA;        break&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;    if ($Reboot) {&#xD;&#xA;        Write-Host &quot;The computer will reboot if needed after installation is complete.&quot;&#xD;&#xA;        Write-Host&#xD;&#xA;    }&#xD;&#xA;    if ($ScanOnly) {&#xD;&#xA;        Write-Host &quot;Running in scan only mode.&quot;&#xD;&#xA;        Write-Host&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    Write-Verbose &quot;Creating Update Session&quot;&#xD;&#xA;    $Session = New-Object -com &quot;Microsoft.Update.Session&quot;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    if ($ProxyAddress -ne $null) {&#xD;&#xA;    Write-Verbose &quot;Setting Proxy&quot;&#xD;&#xA;        $Proxy = New-Object -com &quot;Microsoft.Update.WebProxy&quot;&#xD;&#xA;        $Session.WebProxy.Address = $Proxyaddress&#xD;&#xA;        $Session.WebProxy.AutoDetect = $FALSE&#xD;&#xA;        $Session.WebProxy.BypassProxyOnLocal = $TRUE&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    Write-Verbose &quot;Creating Update Type Array&quot;&#xD;&#xA;    foreach($UpdateType in $UpdateTypes)&#xD;&#xA;    {&#xD;&#xA;        $UpdateID&#xD;&#xA;        switch ($UpdateType)&#xD;&#xA;        {&#xD;&#xA;        &quot;Critical&quot; {$UpdateID = 0}&#xD;&#xA;        &quot;Definition&quot;{$UpdateID = 1}&#xD;&#xA;        &quot;Drivers&quot;{$UpdateID = 2}&#xD;&#xA;        &quot;FeaturePacks&quot;{$UpdateID = 3}&#xD;&#xA;        &quot;Security&quot;{$UpdateID = 4}&#xD;&#xA;        &quot;ServicePacks&quot;{$UpdateID = 5}&#xD;&#xA;        &quot;Tools&quot;{$UpdateID = 6}&#xD;&#xA;        &quot;UpdateRollups&quot;{$UpdateID = 7}&#xD;&#xA;        &quot;Updates&quot;{$UpdateID = 8}&#xD;&#xA;        &quot;Microsoft&quot;{$UpdateID = 9}&#xD;&#xA;        default {$UpdateID=99}&#xD;&#xA;        }&#xD;&#xA;        $UpdateIds += $UpdateID&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    Write-Host &quot;Searching for updates...&quot;&#xD;&#xA;    $Search = $Session.CreateUpdateSearcher()&#xD;&#xA;    $SearchResults = $Search.Search(&quot;IsInstalled=0 and IsHidden=0&quot;)&#xD;&#xA;    Write-Host &quot;There are &quot; $SearchResults.Updates.Count &quot;TOTAL updates available.&quot;&#xD;&#xA;&#xD;&#xA;    if($UpdateIds -eq 99)&#xD;&#xA;    {&#xD;&#xA;        $AvailableUpdates = $SearchResults.Updates&#xD;&#xA;    }&#xD;&#xA;    else{&#xD;&#xA;        &#xD;&#xA;        foreach($UpdateID in $UpdateIds)&#xD;&#xA;        {&#xD;&#xA;            $AvailableUpdates += $SearchResults.RootCategories.Item($UpdateID).Updates&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    Write-Host &quot;Updates selected for installation&quot;&#xD;&#xA;    $AvailableUpdates | ForEach-Object {&#xD;&#xA;    &#xD;&#xA;        if (($_.InstallationBehavior.CanRequestUserInput) -or ($_.EulaAccepted -eq $FALSE)) {&#xD;&#xA;            Write-Host $_.Title &quot; *** Requires user input and will not be installed.&quot; -ForegroundColor Yellow&#xD;&#xA;            if($ShowCategories)&#xD;&#xA;            {&#xD;&#xA;                $_.Categories | ForEach-Object {Write-Host &quot;     &quot;$_.Name.ToString() -ForegroundColor Cyan}&#xD;&#xA;                &#xD;&#xA;            }&#xD;&#xA;                &#xD;&#xA;        }&#xD;&#xA;        else {&#xD;&#xA;            Write-Host $_.Title -ForegroundColor Green&#xD;&#xA;            if($ShowCategories)&#xD;&#xA;            {&#xD;&#xA;                $_.Categories | ForEach-Object {Write-Host &quot;     &quot;$_.Name.ToString() -ForegroundColor Cyan}&#xD;&#xA;                &#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    # Exit script if no updates are available&#xD;&#xA;    if ($ScanOnly) {&#xD;&#xA;        Write-Host &quot;Exiting...&quot;;&#xD;&#xA;        break&#xD;&#xA;    }&#xD;&#xA;    if($AvailableUpdates.count -lt 1){&#xD;&#xA;        Write-Host &quot;No results meet your criteria. Exiting&quot;;&#xD;&#xA;        break&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    Write-Verbose &quot;Creating Download Selection&quot;&#xD;&#xA;    $DownloadCollection = New-Object -com &quot;Microsoft.Update.UpdateColl&quot;&#xD;&#xA;&#xD;&#xA;    $AvailableUpdates | ForEach-Object {&#xD;&#xA;        if ($_.InstallationBehavior.CanRequestUserInput -ne $TRUE) {&#xD;&#xA;            $DownloadCollection.Add($_) | Out-Null&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;    Write-Verbose &quot;Downloading Updates&quot;&#xD;&#xA;    Write-Host &quot;Downloading updates...&quot;&#xD;&#xA;    $Downloader = $Session.CreateUpdateDownloader()&#xD;&#xA;    $Downloader.Updates = $DownloadCollection&#xD;&#xA;    $Downloader.Download()&#xD;&#xA;&#xD;&#xA;    Write-Host &quot;Download complete.&quot;&#xD;&#xA;&#xD;&#xA;    Write-Verbose &quot;Creating Installation Object&quot;&#xD;&#xA;    $InstallCollection = New-Object -com &quot;Microsoft.Update.UpdateColl&quot;&#xD;&#xA;    $AvailableUpdates | ForEach-Object {&#xD;&#xA;&#x9;    if ($_.IsDownloaded) {&#xD;&#xA;&#x9;&#x9;    $InstallCollection.Add($_) | Out-Null&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    Write-Verbose &quot;Installing Updates&quot;&#xD;&#xA;    Write-Host &quot;Installing updates...&quot;&#xD;&#xA;    $Installer = $Session.CreateUpdateInstaller()&#xD;&#xA;    $Installer.Updates = $InstallCollection&#xD;&#xA;    $Results = $Installer.Install()&#xD;&#xA;    Write-Host &quot;Installation complete.&quot;&#xD;&#xA;    Write-Host&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    # Reboot if needed&#xD;&#xA;    if ($Results.RebootRequired) {&#xD;&#xA;        if ($Reboot) {&#xD;&#xA;            Write-Host &quot;Rebooting...&quot;&#xD;&#xA;            Restart-Computer ## add computername here&#xD;&#xA;        }&#xD;&#xA;        else {&#xD;&#xA;&#x9;        Write-Host &quot;Please reboot.&quot;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    else {&#xD;&#xA;&#x9;    Write-Host &quot;No reboot required.&quot;&#xD;&#xA;    }" />
</CodeSnippets>