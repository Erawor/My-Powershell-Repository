<?xml version="1.0" encoding="utf-8"?>
<CodeSnippets>
  <Code Content="Function Get-PendingReboot&#xD;&#xA;{&#xD;&#xA;&lt;#&#xD;&#xA;.SYNOPSIS&#xD;&#xA;    Gets the pending reboot status on a local or remote computer.&#xD;&#xA;&#xD;&#xA;.DESCRIPTION&#xD;&#xA;    This function will query the registry on a local or remote computer and determine if the&#xD;&#xA;    system is pending a reboot, from either Microsoft Patching or a Software Installation.&#xD;&#xA;    For Windows 2008+ the function will query the CBS registry key as another factor in determining&#xD;&#xA;    pending reboot state.  &quot;PendingFileRenameOperations&quot; and &quot;Auto Update\RebootRequired&quot; are observed&#xD;&#xA;    as being consistant across Windows Server 2003 &amp; 2008.&#xD;&#xA;  &#xD;&#xA;    CBServicing = Component Based Servicing (Windows 2008)&#xD;&#xA;    WindowsUpdate = Windows Update / Auto Update (Windows 2003 / 2008)&#xD;&#xA;    CCMClientSDK = SCCM 2012 Clients only (DetermineIfRebootPending method) otherwise $null value&#xD;&#xA;    PendFileRename = PendingFileRenameOperations (Windows 2003 / 2008)&#xD;&#xA;&#xD;&#xA;.PARAMETER ComputerName&#xD;&#xA;    A single Computer or an array of computer names.  The default is localhost ($env:COMPUTERNAME).&#xD;&#xA;&#xD;&#xA;.PARAMETER ErrorLog&#xD;&#xA;    A single path to send error data to a log file.&#xD;&#xA;&#xD;&#xA;.EXAMPLE&#xD;&#xA;    PS C:\&gt; Get-PendingReboot -ComputerName (Get-Content C:\ServerList.txt) | Format-Table -AutoSize&#xD;&#xA;  &#xD;&#xA;    Computer CBServicing WindowsUpdate CCMClientSDK PendFileRename PendFileRenVal RebootPending&#xD;&#xA;    -------- ----------- ------------- ------------ -------------- -------------- -------------&#xD;&#xA;    DC01           False         False                       False                        False&#xD;&#xA;    DC02           False         False                       False                        False&#xD;&#xA;    FS01           False         False                       False                        False&#xD;&#xA;&#xD;&#xA;    This example will capture the contents of C:\ServerList.txt and query the pending reboot&#xD;&#xA;    information from the systems contained in the file and display the output in a table. The&#xD;&#xA;    null values are by design, since these systems do not have the SCCM 2012 client installed,&#xD;&#xA;    nor was the PendingFileRenameOperations value populated.&#xD;&#xA;&#xD;&#xA;.EXAMPLE&#xD;&#xA;    PS C:\&gt; Get-PendingReboot&#xD;&#xA;  &#xD;&#xA;    Computer       : WKS01&#xD;&#xA;    CBServicing    : False&#xD;&#xA;    WindowsUpdate  : True&#xD;&#xA;    CCMClient      : False&#xD;&#xA;    PendFileRename : False&#xD;&#xA;    PendFileRenVal : &#xD;&#xA;    RebootPending  : True&#xD;&#xA;  &#xD;&#xA;    This example will query the local machine for pending reboot information.&#xD;&#xA;  &#xD;&#xA;.EXAMPLE&#xD;&#xA;    PS C:\&gt; $Servers = Get-Content C:\Servers.txt&#xD;&#xA;    PS C:\&gt; Get-PendingReboot -Computer $Servers | Export-Csv C:\PendingRebootReport.csv -NoTypeInformation&#xD;&#xA;  &#xD;&#xA;    This example will create a report that contains pending reboot information.&#xD;&#xA;&#xD;&#xA;.LINK&#xD;&#xA;    Component-Based Servicing:&#xD;&#xA;    http://technet.microsoft.com/en-us/library/cc756291(v=WS.10).aspx&#xD;&#xA;  &#xD;&#xA;    PendingFileRename/Auto Update:&#xD;&#xA;    http://support.microsoft.com/kb/2723674&#xD;&#xA;    http://technet.microsoft.com/en-us/library/cc960241.aspx&#xD;&#xA;    http://blogs.msdn.com/b/hansr/archive/2006/02/17/patchreboot.aspx&#xD;&#xA;&#xD;&#xA;    SCCM 2012/CCM_ClientSDK:&#xD;&#xA;    http://msdn.microsoft.com/en-us/library/jj902723.aspx&#xD;&#xA;&#xD;&#xA;.NOTES&#xD;&#xA;    Author:  Brian Wilhite&#xD;&#xA;    Email:   bwilhite1@carolina.rr.com&#xD;&#xA;    Date:    08/29/2012&#xD;&#xA;    PSVer:   2.0/3.0&#xD;&#xA;    Updated: 05/30/2013&#xD;&#xA;    UpdNote: Added CCMClient property - Used with SCCM 2012 Clients only&#xD;&#xA;             Added ValueFromPipelineByPropertyName=$true to the ComputerName Parameter&#xD;&#xA;             Removed $Data variable from the PSObject - it is not needed&#xD;&#xA;             Bug with the way CCMClientSDK returned null value if it was false&#xD;&#xA;             Removed unneeded variables&#xD;&#xA;             Added PendFileRenVal - Contents of the PendingFileRenameOperations Reg Entry&#xD;&#xA;#&gt;&#xD;&#xA;&#xD;&#xA;[CmdletBinding()]&#xD;&#xA;param(&#xD;&#xA;  [Parameter(Position=0,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]&#xD;&#xA;  [Alias(&quot;CN&quot;,&quot;Computer&quot;)]&#xD;&#xA;  [String[]]$ComputerName=&quot;$env:COMPUTERNAME&quot;,&#xD;&#xA;  [String]$ErrorLog&#xD;&#xA;  )&#xD;&#xA;&#xD;&#xA;Begin&#xD;&#xA;  {&#xD;&#xA;    # Adjusting ErrorActionPreference to stop on all errors, since using [Microsoft.Win32.RegistryKey]&#xD;&#xA;        # does not have a native ErrorAction Parameter, this may need to be changed if used within another&#xD;&#xA;        # function.&#xD;&#xA;    $TempErrAct = $ErrorActionPreference&#xD;&#xA;    $ErrorActionPreference = &quot;Stop&quot;&#xD;&#xA;  }#End Begin Script Block&#xD;&#xA;Process&#xD;&#xA;  {&#xD;&#xA;    Foreach ($Computer in $ComputerName)&#xD;&#xA;      {&#xD;&#xA;        Try&#xD;&#xA;          {&#xD;&#xA;            # Setting pending values to false to cut down on the number of else statements&#xD;&#xA;            $PendFileRename,$Pending,$SCCM = $false,$false,$false&#xD;&#xA;                        &#xD;&#xA;                        # Setting CBSRebootPend to null since not all versions of Windows has this value&#xD;&#xA;                        $CBSRebootPend = $null&#xD;&#xA;            &#xD;&#xA;            # Querying WMI for build version&#xD;&#xA;            $WMI_OS = Get-WmiObject -Class Win32_OperatingSystem -Property BuildNumber, CSName -ComputerName $Computer&#xD;&#xA;&#xD;&#xA;            # Making registry connection to the local/remote computer&#xD;&#xA;            $RegCon = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey([Microsoft.Win32.RegistryHive]&quot;LocalMachine&quot;,$Computer)&#xD;&#xA;            &#xD;&#xA;            # If Vista/2008 &amp; Above query the CBS Reg Key&#xD;&#xA;            If ($WMI_OS.BuildNumber -ge 6001)&#xD;&#xA;              {&#xD;&#xA;                $RegSubKeysCBS = $RegCon.OpenSubKey(&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\&quot;).GetSubKeyNames()&#xD;&#xA;                $CBSRebootPend = $RegSubKeysCBS -contains &quot;RebootPending&quot;&#xD;&#xA;                  &#xD;&#xA;              }#End If ($WMI_OS.BuildNumber -ge 6001)&#xD;&#xA;              &#xD;&#xA;            # Query WUAU from the registry&#xD;&#xA;            $RegWUAU = $RegCon.OpenSubKey(&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\&quot;)&#xD;&#xA;            $RegWUAURebootReq = $RegWUAU.GetSubKeyNames()&#xD;&#xA;            $WUAURebootReq = $RegWUAURebootReq -contains &quot;RebootRequired&quot;&#xD;&#xA;            &#xD;&#xA;            # Query PendingFileRenameOperations from the registry&#xD;&#xA;            $RegSubKeySM = $RegCon.OpenSubKey(&quot;SYSTEM\CurrentControlSet\Control\Session Manager\&quot;)&#xD;&#xA;            $RegValuePFRO = $RegSubKeySM.GetValue(&quot;PendingFileRenameOperations&quot;,$null)&#xD;&#xA;            &#xD;&#xA;            # Closing registry connection&#xD;&#xA;            $RegCon.Close()&#xD;&#xA;            &#xD;&#xA;            # If PendingFileRenameOperations has a value set $RegValuePFRO variable to $true&#xD;&#xA;            If ($RegValuePFRO)&#xD;&#xA;              {&#xD;&#xA;                $PendFileRename = $true&#xD;&#xA;&#xD;&#xA;              }#End If ($RegValuePFRO)&#xD;&#xA;&#xD;&#xA;            # Determine SCCM 2012 Client Reboot Pending Status&#xD;&#xA;            # To avoid nested 'if' statements and unneeded WMI calls to determine if the CCM_ClientUtilities class exist, setting EA = 0&#xD;&#xA;            $CCMClientSDK = $null&#xD;&#xA;                        $CCMSplat = @{&#xD;&#xA;                            NameSpace='ROOT\ccm\ClientSDK'&#xD;&#xA;                            Class='CCM_ClientUtilities'&#xD;&#xA;                            Name='DetermineIfRebootPending'&#xD;&#xA;                            ComputerName=$Computer&#xD;&#xA;                            ErrorAction='SilentlyContinue'&#xD;&#xA;                            }&#xD;&#xA;                        $CCMClientSDK = Invoke-WmiMethod @CCMSplat&#xD;&#xA;            If ($CCMClientSDK)&#xD;&#xA;                            {&#xD;&#xA;                                If ($CCMClientSDK.ReturnValue -ne 0)&#xD;&#xA;                      {&#xD;&#xA;                        Write-Warning &quot;Error: DetermineIfRebootPending returned error code $($CCMClientSDK.ReturnValue)&quot;&#xD;&#xA;                            &#xD;&#xA;                      }#End If ($CCMClientSDK -and $CCMClientSDK.ReturnValue -ne 0)&#xD;&#xA;&#xD;&#xA;                    If ($CCMClientSDK.IsHardRebootPending -or $CCMClientSDK.RebootPending)&#xD;&#xA;                      {&#xD;&#xA;                        $SCCM = $true&#xD;&#xA;&#xD;&#xA;                      }#End If ($CCMClientSDK.IsHardRebootPending -or $CCMClientSDK.RebootPending)&#xD;&#xA;&#xD;&#xA;                            }#End If ($CCMClientSDK)&#xD;&#xA;                        Else&#xD;&#xA;                            {&#xD;&#xA;                                $SCCM = $null&#xD;&#xA;&#xD;&#xA;                            }                        &#xD;&#xA;                        &#xD;&#xA;                        # If any of the variables are true, set $Pending variable to $true&#xD;&#xA;            If ($CBSRebootPend -or $WUAURebootReq -or $SCCM -or $PendFileRename)&#xD;&#xA;              {&#xD;&#xA;                $Pending = $true&#xD;&#xA;&#xD;&#xA;              }#End If ($CBS -or $WUAU -or $PendFileRename)&#xD;&#xA;              &#xD;&#xA;            # Creating Custom PSObject and Select-Object Splat&#xD;&#xA;                        $SelectSplat = @{&#xD;&#xA;                            Property=('Computer','CBServicing','WindowsUpdate','CCMClientSDK','PendFileRename','PendFileRenVal','RebootPending')&#xD;&#xA;                            }&#xD;&#xA;            New-Object -TypeName PSObject -Property @{&#xD;&#xA;                Computer=$WMI_OS.CSName&#xD;&#xA;                CBServicing=$CBSRebootPend&#xD;&#xA;                WindowsUpdate=$WUAURebootReq&#xD;&#xA;                CCMClientSDK=$SCCM&#xD;&#xA;                PendFileRename=$PendFileRename&#xD;&#xA;                                PendFileRenVal=$RegValuePFRO&#xD;&#xA;                RebootPending=$Pending&#xD;&#xA;                } | Select-Object @SelectSplat&#xD;&#xA;&#xD;&#xA;          }#End Try&#xD;&#xA;&#xD;&#xA;        Catch&#xD;&#xA;          {&#xD;&#xA;            Write-Warning &quot;$Computer`: $_&quot;&#xD;&#xA;            &#xD;&#xA;            # If $ErrorLog, log the file to a user specified location/path&#xD;&#xA;            If ($ErrorLog)&#xD;&#xA;              {&#xD;&#xA;                Out-File -InputObject &quot;$Computer`,$_&quot; -FilePath $ErrorLog -Append&#xD;&#xA;&#xD;&#xA;              }#End If ($ErrorLog)&#xD;&#xA;              &#xD;&#xA;          }#End Catch&#xD;&#xA;          &#xD;&#xA;      }#End Foreach ($Computer in $ComputerName)&#xD;&#xA;      &#xD;&#xA;  }#End Process&#xD;&#xA;  &#xD;&#xA;End&#xD;&#xA;  {&#xD;&#xA;    # Resetting ErrorActionPref&#xD;&#xA;    $ErrorActionPreference = $TempErrAct&#xD;&#xA;  }#End End&#xD;&#xA;  &#xD;&#xA;}#End Function" />
  <Code Content="Function Get-PendingReboot&#xD;&#xA;{&#xD;&#xA;&lt;#&#xD;&#xA;.SYNOPSIS&#xD;&#xA;    Gets the pending reboot status on a local or remote computer.&#xD;&#xA;&#xD;&#xA;.DESCRIPTION&#xD;&#xA;    This function will query the registry on a local or remote computer and determine if the&#xD;&#xA;    system is pending a reboot, from either Microsoft Patching or a Software Installation.&#xD;&#xA;    For Windows 2008+ the function will query the CBS registry key as another factor in determining&#xD;&#xA;    pending reboot state.  &quot;PendingFileRenameOperations&quot; and &quot;Auto Update\RebootRequired&quot; are observed&#xD;&#xA;    as being consistant across Windows Server 2003 &amp; 2008.&#xD;&#xA;  &#xD;&#xA;    CBServicing = Component Based Servicing (Windows 2008)&#xD;&#xA;    WindowsUpdate = Windows Update / Auto Update (Windows 2003 / 2008)&#xD;&#xA;    CCMClientSDK = SCCM 2012 Clients only (DetermineIfRebootPending method) otherwise $null value&#xD;&#xA;    PendFileRename = PendingFileRenameOperations (Windows 2003 / 2008)&#xD;&#xA;&#xD;&#xA;.PARAMETER ComputerName&#xD;&#xA;    A single Computer or an array of computer names.  The default is localhost ($env:COMPUTERNAME).&#xD;&#xA;&#xD;&#xA;.PARAMETER ErrorLog&#xD;&#xA;    A single path to send error data to a log file.&#xD;&#xA;&#xD;&#xA;.EXAMPLE&#xD;&#xA;    PS C:\&gt; Get-PendingReboot -ComputerName (Get-Content C:\ServerList.txt) | Format-Table -AutoSize&#xD;&#xA;  &#xD;&#xA;    Computer CBServicing WindowsUpdate CCMClientSDK PendFileRename PendFileRenVal RebootPending&#xD;&#xA;    -------- ----------- ------------- ------------ -------------- -------------- -------------&#xD;&#xA;    DC01           False         False                       False                        False&#xD;&#xA;    DC02           False         False                       False                        False&#xD;&#xA;    FS01           False         False                       False                        False&#xD;&#xA;&#xD;&#xA;    This example will capture the contents of C:\ServerList.txt and query the pending reboot&#xD;&#xA;    information from the systems contained in the file and display the output in a table. The&#xD;&#xA;    null values are by design, since these systems do not have the SCCM 2012 client installed,&#xD;&#xA;    nor was the PendingFileRenameOperations value populated.&#xD;&#xA;&#xD;&#xA;.EXAMPLE&#xD;&#xA;    PS C:\&gt; Get-PendingReboot&#xD;&#xA;  &#xD;&#xA;    Computer       : WKS01&#xD;&#xA;    CBServicing    : False&#xD;&#xA;    WindowsUpdate  : True&#xD;&#xA;    CCMClient      : False&#xD;&#xA;    PendFileRename : False&#xD;&#xA;    PendFileRenVal : &#xD;&#xA;    RebootPending  : True&#xD;&#xA;  &#xD;&#xA;    This example will query the local machine for pending reboot information.&#xD;&#xA;  &#xD;&#xA;.EXAMPLE&#xD;&#xA;    PS C:\&gt; $Servers = Get-Content C:\Servers.txt&#xD;&#xA;    PS C:\&gt; Get-PendingReboot -Computer $Servers | Export-Csv C:\PendingRebootReport.csv -NoTypeInformation&#xD;&#xA;  &#xD;&#xA;    This example will create a report that contains pending reboot information.&#xD;&#xA;&#xD;&#xA;.LINK&#xD;&#xA;    Component-Based Servicing:&#xD;&#xA;    http://technet.microsoft.com/en-us/library/cc756291(v=WS.10).aspx&#xD;&#xA;  &#xD;&#xA;    PendingFileRename/Auto Update:&#xD;&#xA;    http://support.microsoft.com/kb/2723674&#xD;&#xA;    http://technet.microsoft.com/en-us/library/cc960241.aspx&#xD;&#xA;    http://blogs.msdn.com/b/hansr/archive/2006/02/17/patchreboot.aspx&#xD;&#xA;&#xD;&#xA;    SCCM 2012/CCM_ClientSDK:&#xD;&#xA;    http://msdn.microsoft.com/en-us/library/jj902723.aspx&#xD;&#xA;&#xD;&#xA;.NOTES&#xD;&#xA;    Author:  Brian Wilhite&#xD;&#xA;    Email:   bwilhite1@carolina.rr.com&#xD;&#xA;    Date:    08/29/2012&#xD;&#xA;    PSVer:   2.0/3.0&#xD;&#xA;    Updated: 05/30/2013&#xD;&#xA;    UpdNote: Added CCMClient property - Used with SCCM 2012 Clients only&#xD;&#xA;             Added ValueFromPipelineByPropertyName=$true to the ComputerName Parameter&#xD;&#xA;             Removed $Data variable from the PSObject - it is not needed&#xD;&#xA;             Bug with the way CCMClientSDK returned null value if it was false&#xD;&#xA;             Removed unneeded variables&#xD;&#xA;             Added PendFileRenVal - Contents of the PendingFileRenameOperations Reg Entry&#xD;&#xA;#&gt;&#xD;&#xA;&#xD;&#xA;[CmdletBinding()]&#xD;&#xA;param(&#xD;&#xA;  [Parameter(Position=0,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]&#xD;&#xA;  [Alias(&quot;CN&quot;,&quot;Computer&quot;)]&#xD;&#xA;  [String[]]$ComputerName=&quot;$env:COMPUTERNAME&quot;,&#xD;&#xA;  [String]$ErrorLog&#xD;&#xA;  )&#xD;&#xA;&#xD;&#xA;Begin&#xD;&#xA;  {&#xD;&#xA;    # Adjusting ErrorActionPreference to stop on all errors, since using [Microsoft.Win32.RegistryKey]&#xD;&#xA;        # does not have a native ErrorAction Parameter, this may need to be changed if used within another&#xD;&#xA;        # function.&#xD;&#xA;    $TempErrAct = $ErrorActionPreference&#xD;&#xA;    $ErrorActionPreference = &quot;Stop&quot;&#xD;&#xA;  }#End Begin Script Block&#xD;&#xA;Process&#xD;&#xA;  {&#xD;&#xA;    Foreach ($Computer in $ComputerName)&#xD;&#xA;      {&#xD;&#xA;        Try&#xD;&#xA;          {&#xD;&#xA;            # Setting pending values to false to cut down on the number of else statements&#xD;&#xA;            $PendFileRename,$Pending,$SCCM = $false,$false,$false&#xD;&#xA;                        &#xD;&#xA;                        # Setting CBSRebootPend to null since not all versions of Windows has this value&#xD;&#xA;                        $CBSRebootPend = $null&#xD;&#xA;            &#xD;&#xA;            # Querying WMI for build version&#xD;&#xA;            $WMI_OS = Get-WmiObject -Class Win32_OperatingSystem -Property BuildNumber, CSName -ComputerName $Computer&#xD;&#xA;&#xD;&#xA;            # Making registry connection to the local/remote computer&#xD;&#xA;            $RegCon = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey([Microsoft.Win32.RegistryHive]&quot;LocalMachine&quot;,$Computer)&#xD;&#xA;            &#xD;&#xA;            # If Vista/2008 &amp; Above query the CBS Reg Key&#xD;&#xA;            If ($WMI_OS.BuildNumber -ge 6001)&#xD;&#xA;              {&#xD;&#xA;                $RegSubKeysCBS = $RegCon.OpenSubKey(&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\&quot;).GetSubKeyNames()&#xD;&#xA;                $CBSRebootPend = $RegSubKeysCBS -contains &quot;RebootPending&quot;&#xD;&#xA;                  &#xD;&#xA;              }#End If ($WMI_OS.BuildNumber -ge 6001)&#xD;&#xA;              &#xD;&#xA;            # Query WUAU from the registry&#xD;&#xA;            $RegWUAU = $RegCon.OpenSubKey(&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\&quot;)&#xD;&#xA;            $RegWUAURebootReq = $RegWUAU.GetSubKeyNames()&#xD;&#xA;            $WUAURebootReq = $RegWUAURebootReq -contains &quot;RebootRequired&quot;&#xD;&#xA;            &#xD;&#xA;            # Query PendingFileRenameOperations from the registry&#xD;&#xA;            $RegSubKeySM = $RegCon.OpenSubKey(&quot;SYSTEM\CurrentControlSet\Control\Session Manager\&quot;)&#xD;&#xA;            $RegValuePFRO = $RegSubKeySM.GetValue(&quot;PendingFileRenameOperations&quot;,$null)&#xD;&#xA;            &#xD;&#xA;            # Closing registry connection&#xD;&#xA;            $RegCon.Close()&#xD;&#xA;            &#xD;&#xA;            # If PendingFileRenameOperations has a value set $RegValuePFRO variable to $true&#xD;&#xA;            If ($RegValuePFRO)&#xD;&#xA;              {&#xD;&#xA;                $PendFileRename = $true&#xD;&#xA;&#xD;&#xA;              }#End If ($RegValuePFRO)&#xD;&#xA;&#xD;&#xA;            # Determine SCCM 2012 Client Reboot Pending Status&#xD;&#xA;            # To avoid nested 'if' statements and unneeded WMI calls to determine if the CCM_ClientUtilities class exist, setting EA = 0&#xD;&#xA;            $CCMClientSDK = $null&#xD;&#xA;                        $CCMSplat = @{&#xD;&#xA;                            NameSpace='ROOT\ccm\ClientSDK'&#xD;&#xA;                            Class='CCM_ClientUtilities'&#xD;&#xA;                            Name='DetermineIfRebootPending'&#xD;&#xA;                            ComputerName=$Computer&#xD;&#xA;                            ErrorAction='SilentlyContinue'&#xD;&#xA;                            }&#xD;&#xA;                        $CCMClientSDK = Invoke-WmiMethod @CCMSplat&#xD;&#xA;            If ($CCMClientSDK)&#xD;&#xA;                            {&#xD;&#xA;                                If ($CCMClientSDK.ReturnValue -ne 0)&#xD;&#xA;                      {&#xD;&#xA;                        Write-Warning &quot;Error: DetermineIfRebootPending returned error code $($CCMClientSDK.ReturnValue)&quot;&#xD;&#xA;                            &#xD;&#xA;                      }#End If ($CCMClientSDK -and $CCMClientSDK.ReturnValue -ne 0)&#xD;&#xA;&#xD;&#xA;                    If ($CCMClientSDK.IsHardRebootPending -or $CCMClientSDK.RebootPending)&#xD;&#xA;                      {&#xD;&#xA;                        $SCCM = $true&#xD;&#xA;&#xD;&#xA;                      }#End If ($CCMClientSDK.IsHardRebootPending -or $CCMClientSDK.RebootPending)&#xD;&#xA;&#xD;&#xA;                            }#End If ($CCMClientSDK)&#xD;&#xA;                        Else&#xD;&#xA;                            {&#xD;&#xA;                                $SCCM = $null&#xD;&#xA;&#xD;&#xA;                            }                        &#xD;&#xA;                        &#xD;&#xA;                        # If any of the variables are true, set $Pending variable to $true&#xD;&#xA;            If ($CBSRebootPend -or $WUAURebootReq -or $SCCM -or $PendFileRename)&#xD;&#xA;              {&#xD;&#xA;                $Pending = $true&#xD;&#xA;&#xD;&#xA;              }#End If ($CBS -or $WUAU -or $PendFileRename)&#xD;&#xA;              &#xD;&#xA;            # Creating Custom PSObject and Select-Object Splat&#xD;&#xA;                        $SelectSplat = @{&#xD;&#xA;                            Property=('Computer','CBServicing','WindowsUpdate','CCMClientSDK','PendFileRename','PendFileRenVal','RebootPending')&#xD;&#xA;                            }&#xD;&#xA;            New-Object -TypeName PSObject -Property @{&#xD;&#xA;                Computer=$WMI_OS.CSName&#xD;&#xA;                CBServicing=$CBSRebootPend&#xD;&#xA;                WindowsUpdate=$WUAURebootReq&#xD;&#xA;                CCMClientSDK=$SCCM&#xD;&#xA;                PendFileRename=$PendFileRename&#xD;&#xA;                                PendFileRenVal=$RegValuePFRO&#xD;&#xA;                RebootPending=$Pending&#xD;&#xA;                } | Select-Object @SelectSplat&#xD;&#xA;&#xD;&#xA;          }#End Try&#xD;&#xA;&#xD;&#xA;        Catch&#xD;&#xA;          {&#xD;&#xA;            Write-Warning &quot;$Computer`: $_&quot;&#xD;&#xA;            &#xD;&#xA;            # If $ErrorLog, log the file to a user specified location/path&#xD;&#xA;            If ($ErrorLog)&#xD;&#xA;              {&#xD;&#xA;                Out-File -InputObject &quot;$Computer`,$_&quot; -FilePath $ErrorLog -Append&#xD;&#xA;&#xD;&#xA;              }#End If ($ErrorLog)&#xD;&#xA;              &#xD;&#xA;          }#End Catch&#xD;&#xA;          &#xD;&#xA;      }#End Foreach ($Computer in $ComputerName)&#xD;&#xA;      &#xD;&#xA;  }#End Process&#xD;&#xA;  &#xD;&#xA;End&#xD;&#xA;  {&#xD;&#xA;    # Resetting ErrorActionPref&#xD;&#xA;    $ErrorActionPreference = $TempErrAct&#xD;&#xA;  }#End End&#xD;&#xA;  &#xD;&#xA;}#End Function" />
</CodeSnippets>