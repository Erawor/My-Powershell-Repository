<?xml version="1.0" encoding="utf-8"?>
<CodeSnippets>
  <Code Content="&lt;#----------------------------------------------------------------------------&#xD;&#xA;LEGAL DISCLAIMER &#xD;&#xA;This Sample Code is provided for the purpose of illustration only and is not &#xD;&#xA;intended to be used in a production environment.  THIS SAMPLE CODE AND ANY &#xD;&#xA;RELATED INFORMATION ARE PROVIDED &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER &#xD;&#xA;EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF &#xD;&#xA;MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.  We grant You a &#xD;&#xA;nonexclusive, royalty-free right to use and modify the Sample Code and to &#xD;&#xA;reproduce and distribute the object code form of the Sample Code, provided &#xD;&#xA;that You agree: (i) to not use Our name, logo, or trademarks to market Your &#xD;&#xA;software product in which the Sample Code is embedded; (ii) to include a valid &#xD;&#xA;copyright notice on Your software product in which the Sample Code is embedded; &#xD;&#xA;and (iii) to indemnify, hold harmless, and defend Us and Our suppliers from and &#xD;&#xA;against any claims or lawsuits, including attorneys’ fees, that arise or result &#xD;&#xA;from the use or distribution of the Sample Code. &#xD;&#xA;  &#xD;&#xA;This posting is provided &quot;AS IS&quot; with no warranties, and confers no rights. Use &#xD;&#xA;of included script samples are subject to the terms specified &#xD;&#xA;at http://www.microsoft.com/info/cpyright.htm. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Author: Tom Moser, PFE&#xD;&#xA;Date: 5/13/2014&#xD;&#xA;Update1: 1/2/2015&#xD;&#xA;&#xD;&#xA;Version 1.0&#xD;&#xA;-Initial Release&#xD;&#xA;&#xD;&#xA;Version 1.1&#xD;&#xA;-Bug fixes&#xD;&#xA;    -Remove Ink and Handwriting Feature&#xD;&#xA;    -Fix typos in KB&#xD;&#xA;    -Change test to see if hotfix is installed&#xD;&#xA;-Thanks to all of the Script Center commenters for feedback!&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Usage: .\Cleanup-Disk.Ps1 [-NoReboot] [-LogPath &lt;String&gt;]&#xD;&#xA;&#xD;&#xA;Switch: NoReboot - Specify this switch ONLY if you DO NOT want the server to reboot&#xD;&#xA;        post update. It is recommendend that you do NOT use this switch.&#xD;&#xA;&#xD;&#xA;        LogPath - Specify this parameter with a log location to write out the script log.&#xD;&#xA;                  Will default to log.txt in the script directory.&#xD;&#xA;&#xD;&#xA;Notes: In order to schedule the script successfully, the name must remain Cleanup-Disk.ps1.&#xD;&#xA;       The log file will contain all relevent information - no console output should be expected. &#xD;&#xA;&#xD;&#xA;Summary:&#xD;&#xA;    This script requires KB2852386.&#xD;&#xA;&#xD;&#xA;    The script itself will perform the following:&#xD;&#xA;        -Verify the KB is installed &#xD;&#xA;        -Install the Desktop Experience feature &#xD;&#xA;        -Install a scheduled task that restarts the script 60 seconds after reboot &#xD;&#xA;        -Reboot, if necessary &#xD;&#xA;        -Update registry keys for cleanmgr.exe to run. &#xD;&#xA;        -Run cleanmgr.exe &#xD;&#xA;        -Reboot &#xD;&#xA;        -Remove Desktop Experience &#xD;&#xA;        -Reboot &#xD;&#xA;        -Remove scheduled task &#xD;&#xA;        -Exit &#xD;&#xA;&#xD;&#xA;-----------------------------------------------------------------------------#&gt;&#xD;&#xA;#Requires -RunAsAdministrator &#xD;&#xA;#Requires -Module ServerManager&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Param([string]$LogPath=&quot;$(join-path $(split-path -parent $MyInvocation.MyCommand.Definition) log.txt)&quot;,      &#xD;&#xA;      [switch]$NoReboot=$false)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;if((get-hotfix KB2852386).HotFixID -ne &quot;KB2852386&quot;)&#xD;&#xA;{&#xD;&#xA;    Write-Error &quot;KB2852386 is required for script. Please install hotfix and re-run.&quot;&#xD;&#xA;    Exit&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#Reg Paths/Vars&#xD;&#xA;Set-Variable -Name ScriptRegKey -Value &quot;HKLM:\Software\WinSXSCleanup&quot; -Option Constant&#xD;&#xA;Set-Variable -Name ScriptRegValueName -Value &quot;Phase&quot; -Option Constant&#xD;&#xA;Set-Variable -Name ScriptSageValueName -Value &quot;SageSet&quot; -Option Constant&#xD;&#xA;Set-Variable -Name ScriptSpaceBeforeValue -Value &quot;SpaceBefore&quot; -Option Constant&#xD;&#xA;Set-Variable -Name SchTaskName -Value &quot;CleanMgr Task Cleanup&quot; -Option Constant&#xD;&#xA;Set-Variable -Name ScriptDEStatusatStart -Value &quot;DEInstalledAtStart&quot; -Option Constant&#xD;&#xA;Set-Variable -Name ScriptInkStatusAtStart -Value &quot;InkInstalledAtStart&quot; -Option Constant&#xD;&#xA;Set-Variable -Name UpdateCleanupPath -value &quot;HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VolumeCaches\Update Cleanup&quot; -Option Constant&#xD;&#xA;Set-Variable -Name ServicePackCleanupPath -Value &quot;HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VolumeCaches\Service Pack Cleanup&quot; -Option Constant&#xD;&#xA;Set-Variable -Name VolumeCachesPath -Value &quot;HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VolumeCaches&quot; -Option Constant&#xD;&#xA;Set-Variable -Name StateFlagClean -Value 2 -Option Constant&#xD;&#xA;Set-Variable -Name StateFlagNoAction -Value 0 -Option Constant&#xD;&#xA;&#xD;&#xA;$ScriptPath = split-path -parent $MyInvocation.MyCommand.Definition&#xD;&#xA;&#xD;&#xA;#Phase Constants&#xD;&#xA;Set-Variable -Name PhaseInit -Value -1 -Option Constant&#xD;&#xA;Set-Variable -Name PhaseStarted -Value 0 -Option Constant&#xD;&#xA;Set-Variable -Name PhaseDEInstalled -Value 1 -Option Constant&#xD;&#xA;Set-Variable -Name PhaseSageSetComplete -Value 2 -Option Constant&#xD;&#xA;Set-Variable -Name PhaseSageRunStarted -Value 3 -Option Constant&#xD;&#xA;Set-Variable -Name PhaseSageRunComplete -Value 4 -Option Constant&#xD;&#xA;Set-Variable -Name PhaseDERemoved -Value 5 -Option Constant&#xD;&#xA;Set-Variable -Name PhaseTaskRemoved -Value 6 -Option Constant&#xD;&#xA;&#xD;&#xA;#import-module&#xD;&#xA;Import-Module ServerManager&#xD;&#xA;&#xD;&#xA;#read state value, use switch statement&#xD;&#xA;&#xD;&#xA;Function DateStamp&#xD;&#xA;{&#xD;&#xA;    return &quot;$(Get-Date -UFormat %Y%m%d-%H%M%S):&quot;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Function LogEntry([string]$LogData)&#xD;&#xA;{&#xD;&#xA;    Add-Content $LogPath &quot;$(DateStamp) $LogData&quot;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Function GetCurrentState&#xD;&#xA;{&#xD;&#xA;   return (Get-ItemProperty -Path $ScriptRegKey -Name $ScriptRegValueName -ErrorAction SilentlyContinue).Phase&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Function CreateScheduledTask&#xD;&#xA;{&#xD;&#xA;    Param([string]$ScriptPath, &#xD;&#xA;          [string]$TaskName,&#xD;&#xA;          [string]$fLogPath,&#xD;&#xA;          [string]$fNoReboot=$false)&#xD;&#xA;    try&#xD;&#xA;    {&#xD;&#xA;        $Scheduler = New-Object -ComObject &quot;Schedule.Service&quot;&#xD;&#xA;        $Scheduler.Connect(&quot;Localhost&quot;)&#xD;&#xA;        $root = $Scheduler.GetFolder(&quot;\&quot;)&#xD;&#xA;        $newTask = $Scheduler.NewTask(0)&#xD;&#xA;        $newTask.RegistrationInfo.Author = $TaskName&#xD;&#xA;        $newTask.RegistrationInfo.Description = &quot;&quot;&#xD;&#xA;        $newtask.Settings.StartWhenAvailable = $true&#xD;&#xA;        $trigger = $newTask.Triggers.Create(8) #Trigger at boot&#xD;&#xA;        $trigger.Delay = &quot;PT60S&quot;&#xD;&#xA;        $trigger.Id = &quot;LogonTriggerId&quot;&#xD;&#xA;        $newTask.Principal.UserId = &quot;NT AUTHORITY\SYSTEM&quot;&#xD;&#xA;        $newTask.Principal.RunLevel = 1&#xD;&#xA;        $newTask.Principal.LogonType = 5&#xD;&#xA;&#xD;&#xA;        $action = $newtask.Actions.Create(0)&#xD;&#xA;        $action.Path = &quot;C:\Windows\system32\WindowsPowerShell\v1.0\powershell.exe&quot;&#xD;&#xA;        &#xD;&#xA;        if($fNoReboot -eq $true)&#xD;&#xA;        {&#xD;&#xA;            $action.Arguments = &quot;-command `&quot;$(join-path $ScriptPath cleanup-disk.ps1)`&quot; -LogPath `&quot;$fLogPath`&quot; -NoReboot -NonInteractive -NoLogo -Version 2&quot;&#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;            $action.Arguments = &quot;-command `&quot;$(join-path $ScriptPath cleanup-disk.ps1)`&quot; -LogPath `&quot;$fLogPath`&quot; -NonInteractive -NoLogo -Version 2&quot;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        $root.RegisterTaskDefinition(&quot;CleanMgr Cleanup Task&quot;, $newTask, 6, &quot;NT AUTHORITY\SYSTEM&quot;, $null , 4)&#xD;&#xA;    }&#xD;&#xA;    catch&#xD;&#xA;    {&#xD;&#xA;        LogEntry &quot;Failed to register scheduled task.&quot; &#xD;&#xA;        LogEntry $Error[0].Exception&#xD;&#xA;        throw &quot;Failed to register scheduled task...&quot;&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;Function DeleteScheduledTask&#xD;&#xA;{&#xD;&#xA;    Param([string]$TaskName)&#xD;&#xA;    c:\windows\system32\schtasks.exe /delete /TN &quot;CleanMgr Cleanup Task&quot; /f&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Function CheckPendingReboot&#xD;&#xA;{&#xD;&#xA;    return Test-Path &quot;HKLM:\Software\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending&quot;    &#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;if(Test-Path $ScriptRegKey)&#xD;&#xA;{&#xD;&#xA;    $CurrentState = GetCurrentState&#xD;&#xA;}&#xD;&#xA;else&#xD;&#xA;{&#xD;&#xA;    $CurrentState = $PhaseInit&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;if(($CurrentState -eq $PhaseInit) -and (CheckPendingReboot -eq $true))&#xD;&#xA;{&#xD;&#xA;    Write-Host -ForegroundColor 'Red' &quot;Reboot pending. Please reboot system and rerun script.&quot;&#xD;&#xA;    LogEntry &quot;*** Reboot pending during initial phase. Reboot and rerun script!&quot;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;LogEntry &quot;CurrentState: $CurrentState&quot;&#xD;&#xA;LogEntry &quot;NoReboot Flag: $NoReboot&quot;&#xD;&#xA;&#xD;&#xA;do&#xD;&#xA;{&#xD;&#xA;    LogEntry &quot;**** Current State: $CurrentState&quot;&#xD;&#xA;&#xD;&#xA;    #Evalute current state against all possibilities.&#xD;&#xA;    Switch($CurrentState)&#xD;&#xA;    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               &#xD;&#xA;    &#xD;&#xA;    $PhaseInit&#xD;&#xA;    {        &#xD;&#xA;        LogEntry &quot;Switch: Null&quot;&#xD;&#xA;&#xD;&#xA;        try&#xD;&#xA;        {   &#xD;&#xA;            #Calculate and log freespace        &#xD;&#xA;            $FreeSpace = (Get-WmiObject win32_logicaldisk | where { $_.DeviceID -eq $env:SystemDrive }).FreeSpace&#xD;&#xA;            if((Test-Path $ScriptRegKey) -eq $false)&#xD;&#xA;            {&#xD;&#xA;                New-Item -Path $ScriptRegKey&#xD;&#xA;            }&#xD;&#xA;            Set-ItemProperty -Path $ScriptRegKey -Name $ScriptSpaceBeforeValue -Value $FreeSpace&#xD;&#xA;            LogEntry &quot;PhaseInit: Current Free Space: $([Math]::Round(($FreeSpace / 1GB),2))GB&quot;&#xD;&#xA;            &#xD;&#xA;             #Check to see if DE is already installed.&#xD;&#xA;            #If yes, set reg key to 1, else 0. Used to prevent DE from uninstalling unintentionally.&#xD;&#xA;            if((Get-WindowsFeature Desktop-Experience).Installed -eq $true)&#xD;&#xA;            {&#xD;&#xA;                Set-ItemProperty -Path $ScriptRegKey -name $ScriptDEStatusAtStart -Value 1&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {&#xD;&#xA;                Set-ItemProperty -Path $ScriptRegKey -name $ScriptDEStatusAtStart -Value 0&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            if((Get-WindowsFeature Ink-Handwriting).Installed -eq $true)&#xD;&#xA;            {&#xD;&#xA;                Set-ItemProperty -Path $ScriptRegKey -Name $ScriptInkStatusAtStart -Value 1&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {&#xD;&#xA;                Set-ItemProperty -Path $ScriptRegKey -Name $ScriptInkStatusAtStart -Value 0&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            &#xD;&#xA;            #Start Installing DE                        &#xD;&#xA;            LogEntry &quot;Feature: Installing Desktop Experience.&quot; &#xD;&#xA;            $FeatureResult = Add-WindowsFeature Desktop-Experience&#xD;&#xA;            LogEntry &quot;PhaseInit: Feature: ExitCode: $($FeatureResult.ExitCode)&quot;&#xD;&#xA;            LogEntry &quot;PhaseInit: Feature: RestartRequired: $($FeatureResult.RestartNeeded)&quot;&#xD;&#xA;            LogEntry &quot;PhaseInit: Feature: Success: $($FeatureResult.Success)&quot;&#xD;&#xA;&#xD;&#xA;            #If DE fails, throw error. &#xD;&#xA;            if($FeatureResult.Success -eq $false -and $FeatureResult.RestartNeeded -eq &quot;No&quot;)&#xD;&#xA;            {&#xD;&#xA;                throw &quot;PhaseInit: Failed to install Desktop Experience. This is a required feature for WinSXS Cleanup.&quot;&#xD;&#xA;            }&#xD;&#xA;           &#xD;&#xA;            #If DE exists with no change needed or success, update reg keys. Reboot if required. Create task.&#xD;&#xA;            elseif($FeatureResult.ExitCode -eq &quot;NoChangeNeeded&quot; -or ($FeatureResult.Success))&#xD;&#xA;            {&#xD;&#xA;                LogEntry &quot;PhaseInit: Feature: Desktop Experience Installed. Updating $ScriptRegKey\$ScriptRegValueName to $PhaseStarted&quot;&#xD;&#xA;                #New-Item $ScriptRegKey -Force&#xD;&#xA;                New-ItemProperty -Path $ScriptRegKey -Name $ScriptRegValueName -Value $PhaseStarted -Force&#xD;&#xA;                &#xD;&#xA;                if($NoReboot -eq $false -and $FeatureResult.RestartNeeded -eq &quot;Yes&quot;)&#xD;&#xA;                {                    &#xD;&#xA;                    LogEntry &quot;PhastInit: Creating Scheduled Task...&quot;&#xD;&#xA;                    CreateScheduledTask -ScriptPath $ScriptPath -TaskName $SchTaskName -fLogPath $LogPath &#xD;&#xA;                    LogEntry &quot;PhaseInit: Created Scheduled Task $SchTaskName&quot;                    &#xD;&#xA;                    $CurrentState = GetCurrentState&#xD;&#xA;                    Restart-Computer&#xD;&#xA;                    Sleep 10&#xD;&#xA;                }&#xD;&#xA;                elseif($FeatureResult.ExitCode -eq &quot;NoChangeNeeded&quot;)&#xD;&#xA;                {&#xD;&#xA;                    LogEntry &quot;DE Already Installed. No reboot required.&quot;&#xD;&#xA;                    LogEntry &quot;PhastInit: Creating Scheduled Task...&quot;&#xD;&#xA;                    CreateScheduledTask -ScriptPath &quot;$ScriptPath&quot; -TaskName $SchTaskName -fLogPath $LogPath -fNoReboot &quot;`$$NoReboot&quot;&#xD;&#xA;                    LogEntry &quot;PhaseInit: Created Scheduled Task $SchTaskName&quot;&#xD;&#xA;&#xD;&#xA;                    $CurrentState = GetCurrentState&#xD;&#xA;                }                &#xD;&#xA;                else&#xD;&#xA;                {&#xD;&#xA;                    CreateScheduledTask -ScriptPath &quot;$ScriptPath&quot; -TaskName $SchTaskName -fLogPath $LogPath -fNoReboot &quot;`$$NoReboot&quot;&#xD;&#xA;                    LogEntry &quot;Phaseinit: Restart switch not specified. Please manually reboot the server to continue cleanup.&quot;&#xD;&#xA;                    Exit&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        catch&#xD;&#xA;        {&#xD;&#xA;            LogEntry $error[0]&#xD;&#xA;            exit&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        break&#xD;&#xA;    }           &#xD;&#xA;&#xD;&#xA;    $PhaseStarted&#xD;&#xA;    {&#xD;&#xA;      LogEntry &quot;PhaseStarted: Verifying DE installation...&quot;&#xD;&#xA;      if((Get-WindowsFeature Desktop-Experience).Installed -eq $true) #check for pending reboot&#xD;&#xA;      {&#xD;&#xA;        LogEntry &quot;PhaseStarted: DE Installed. Moving to PhaseDEInstalled.&quot;&#xD;&#xA;        Set-ItemProperty -Path $ScriptRegKey -Name $ScriptRegValueName -Value $PhaseDEInstalled&#xD;&#xA;      }&#xD;&#xA;      Else&#xD;&#xA;      {&#xD;&#xA;        LogEntry &quot;PhaseStarted: DE not installed. Resetting phase to null.&quot;&#xD;&#xA;        New-ItemProperty -Path $ScriptRegKey -Name $ScriptRegValueName -Value $null&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;      $CurrentState = GetCurrentState&#xD;&#xA;      break&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    $PhaseDEInstalled&#xD;&#xA;    {&#xD;&#xA;        try&#xD;&#xA;        {&#xD;&#xA;            LogEntry &quot;PhaseDEInstalled: Starting PhaseDEInstalled...&quot;&#xD;&#xA;            LogEntry &quot;PhaseDEInstalled: Setting SagetSet...&quot;&#xD;&#xA;            #use static SageSet Value. Insert in to registry.&#xD;&#xA;            $SageSet = &quot;0010&quot;&#xD;&#xA;            Set-Variable -Name StateFlags -Value &quot;StateFlags$SageSet&quot; -Option Constant          &#xD;&#xA;            LogEntry &quot;PhaseDEInstalled: SageSet complete.&quot;&#xD;&#xA;            LogEntry &quot;PhaseDEInstalled: Setting VolumeCaches reg keys...&quot;&#xD;&#xA;            #Set all VolumeCache keys to StateFlags = 0 to prevent cleanup. After, set the proper keys to 2 to allow cleanup.&#xD;&#xA;            $SubKeys = Get-Childitem HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VolumeCaches&#xD;&#xA;            Foreach ($Key in $SubKeys)&#xD;&#xA;            {&#xD;&#xA;                Set-ItemProperty -Path $Key.PSPath -Name $StateFlags -Value $StateFlagNoAction&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            LogEntry &quot;PhaseDEInstalled: VolumeCaches keys set.&quot;&#xD;&#xA;            LogEntry &quot;PhaseDEInstalled: Setting UPdate and Service Pack Keys...&quot;&#xD;&#xA;            #Set all script reg values for persistence through reboots.&#xD;&#xA;            Set-ItemProperty -Path $ScriptRegKey -Name $ScriptSageValueName -Value $SageSet&#xD;&#xA;            Set-ItemProperty -Path $UpdateCleanUpPath -Name $StateFlags -Value $StateFlagClean&#xD;&#xA;            Set-ItemProperty -Path $ServicePackCleanUpPath -Name $StateFlags -Value $StateFlagClean                                                                &#xD;&#xA;            LogEntry &quot;PhaseDEInstalled: Done.&quot; &#xD;&#xA;&#xD;&#xA;            #Update state key&#xD;&#xA;            Set-ItemProperty -Path $ScriptRegKey -Name $ScriptRegValueName -Value $PhaseSageSetComplete&#xD;&#xA;            $CurrentState = GetCurrentState&#xD;&#xA;            LogEntry &quot;PhaseDEInstalled: Complete.&quot;&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        catch&#xD;&#xA;        {&#xD;&#xA;            LogEntry &quot;PhaseDEInstalled: Failed to update reg keys.&quot;&#xD;&#xA;            LogEntry $Error[0].Exception&#xD;&#xA;        }&#xD;&#xA;        break&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    $PhaseSageSetComplete&#xD;&#xA;    {&#xD;&#xA;        LogEntry &quot;PhaseSageSetComplete: Starting cleanmgr.&quot;&#xD;&#xA;        try&#xD;&#xA;        {&#xD;&#xA;            $SageSet = (Get-ItemProperty -Path $ScriptRegKey -Name $ScriptSageValueName).SageSet&#xD;&#xA;                        &#xD;&#xA;            LogEntry &quot;PhaseSageSetComplete: CleanMgr.exe running... &quot;            &#xD;&#xA;            $StartTime = Get-Date&#xD;&#xA;            &amp;&quot;C:\Windows\System32\Cleanmgr.exe&quot; + &quot; /sagerun:$SageSet&quot;            &#xD;&#xA;            Wait-Process cleanmgr&#xD;&#xA;            $EndTime = Get-Date&#xD;&#xA;            LogEntry &quot;PhaseSageSetComplete: CleanMgr.exe complete...&quot;&#xD;&#xA;            LogEntry &quot;PhaseSageSetComplete: Seconds Elapsed: $((New-TimeSpan $StartTime $EndTime).TotalSeconds)&quot;&#xD;&#xA;            LogEntry &quot;PhaseSageSetComplete: Updating State...&quot;&#xD;&#xA;            Set-ItemProperty -Path $ScriptRegKey -Name $ScriptRegValueName -Value $PhaseSageRunComplete&#xD;&#xA;            $CurrentState = GetCurrentState&#xD;&#xA;            LogEntry &quot;PhaseSageSetComplete: Complete.&quot;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        catch&#xD;&#xA;        {&#xD;&#xA;            LogEntry &quot;PhaseSageSetComplete: ERROR.&quot;            &#xD;&#xA;            LogEntry $Error[0].Exception&#xD;&#xA;        }    &#xD;&#xA;        break    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    $PhaseSageRunComplete&#xD;&#xA;    {&#xD;&#xA;        try&#xD;&#xA;        {   &#xD;&#xA;            $DEStatusInit = (Get-ItemProperty -Path $ScriptRegKey -Name $ScriptDEStatusAtStart).&quot;$ScriptDEStatusAtStart&quot;&#xD;&#xA;            $InkStatusInit = (Get-ItemProperty -Path $scriptRegKey -Name $ScriptInkStatusAtStart).&quot;$ScriptInkStatusAtStart&quot;&#xD;&#xA;&#xD;&#xA;            LogEntry &quot;PhaseSageRunComplete: Starting PhaseSageRunComplete.&quot;&#xD;&#xA;            LogEntry &quot;PhaseSageRunComplete: Getting DE Status.&quot;&#xD;&#xA;            &#xD;&#xA;            $DEStatus = (Get-WindowsFeature Desktop-Experience).Installed&#xD;&#xA;            $InkStatus = (Get-WindowsFeature Ink-Handwriting).Installed&#xD;&#xA;&#xD;&#xA;            if($DEStatus -and $DEStatusInit -eq 0)&#xD;&#xA;            {&#xD;&#xA;                $RemoveDE = $true&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {&#xD;&#xA;                $RemoveDE = $false&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            if($InkStatus -and $InkStatusInit -eq 0)&#xD;&#xA;            {&#xD;&#xA;               $RemoveInk = $true&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {&#xD;&#xA;                $RemoveInk = $false&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            LogEntry &quot;PhaseSageRunComplete: DEInstalled = $DEStatus&quot;&#xD;&#xA;            LogEntry &quot;PhaseSageRunComplete: DEStatus at Start was $DEStatusInit&quot;&#xD;&#xA;            LogEntry &quot;PhaseSageRunComplete: RemoveDE is $RemoveDE&quot;&#xD;&#xA;            LogEntry &quot;PhaseSageRunComplete: InkInstalled = $InkStatus&quot;&#xD;&#xA;            LogEntry &quot;PhaseSageRunComplete: InkStatus at start was $InkStatusInit&quot;&#xD;&#xA;            LogEntry &quot;PhaseSageRunComplete: RemoveInk is $RemoveInk&quot;            &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;            #if($DEStatusInit -eq 1)&#xD;&#xA;            if($RemoveDE -eq $false)&#xD;&#xA;            {&#xD;&#xA;                LogEntry &quot;PhaseSageRunComplete: DE removal not required. Continuing...&quot;&#xD;&#xA;                Set-ItemProperty -Path $ScriptRegKey -Name $ScriptRegValueName -Value $PhaseDERemoved&#xD;&#xA;                $CurrentState = GetCurrentState&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            #remove DE if it was not installed                       &#xD;&#xA;            if($RemoveDE -eq $true)&#xD;&#xA;            {                &#xD;&#xA;                if($RemoveInk -eq $true)&#xD;&#xA;                {       &#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Removing DE and Ink-Handwriting&quot;             &#xD;&#xA;                    $DEFeatureResult = (Remove-WindowsFeature Desktop-Experience,Ink-Handwriting)                                    &#xD;&#xA;                }&#xD;&#xA;                else&#xD;&#xA;                {&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Removing only DE.&quot;&#xD;&#xA;                    $DEFeatureResult = (Remove-WindowsFeature Desktop-Experience)                   &#xD;&#xA;                }&#xD;&#xA;                           &#xD;&#xA;                if($NoReboot -eq $false -and $DEFeatureResult.Success -and $DEFeatureResult.RestartNeeded -eq &quot;Yes&quot;)&#xD;&#xA;                {&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Result: $($DEFeatureResult.Success)&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: RestartNeeded: $($DEFeatureResult.RestartNeeded)&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Feature removed successfully.&quot;&#xD;&#xA;                   &#xD;&#xA;                    if($RemoveInk -eq $false)&#xD;&#xA;                    { &#xD;&#xA;                        LogEntry &quot;PhaseSageRunComplete: Rebooting...&quot;&#xD;&#xA;                        Restart-Computer -Force&#xD;&#xA;                        Sleep 10&#xD;&#xA;                    }&#xD;&#xA;                    else&#xD;&#xA;                    {&#xD;&#xA;                        LogEntry &quot;PhaseSageRunComplete: Postponing reboot to remove Ink-Handwriting...&quot;&#xD;&#xA;                    }&#xD;&#xA;                   &#xD;&#xA;                }&#xD;&#xA;                elseif(($NoReboot -eq $false) -and ($DEFeatureResult.Success -eq $false) -and ($DEFeatureResult.RestartNeeded -eq &quot;Yes&quot;))&#xD;&#xA;                {&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Result: $($DEFeatureResult.Success)&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: RestartNeeded: $($DEFeatureResult.RestartNeeded)&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Reboot already pending. Rebooting...&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Rebooting...&quot;&#xD;&#xA;                    Restart-Computer -Force&#xD;&#xA;                    Sleep 10&#xD;&#xA;                }&#xD;&#xA;                Else&#xD;&#xA;                {    &#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Result: $($DEFeatureResult.Success)&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: RestartNeeded: $($DEFeatureResult.RestartNeeded)&quot;                &#xD;&#xA;                    LogEntry &quot;Reboot Required: *** MANUAL REBOOT REQUIRED ***&quot;&#xD;&#xA;                    Exit&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            elseif($DEStatus -eq $false -and $DEStatusInit -eq 0)&#xD;&#xA;            {&#xD;&#xA;                #DE removed, update status&#xD;&#xA;                LogEntry &quot;PhaseSageRunComplete: DE Removed. Updating status...&quot;&#xD;&#xA;                Set-ItemProperty -Path $ScriptRegKey -Name $ScriptRegValueName -Value $PhaseDERemoved&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {      &#xD;&#xA;                LogEntry &quot;PhaseSageRunComplete: ERROR.&quot;            &#xD;&#xA;                LogEntry $Error[0].Exception&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            if($RemoveInk -eq $true -and $RemoveDE -eq $false)&#xD;&#xA;            {&#xD;&#xA;                LogEntry &quot;PhaseSageRunComplete: Removing Ink-Handwriting&quot;&#xD;&#xA;                $InkFeatureResult = (Remove-WindowsFeature Ink-Handwriting)&#xD;&#xA;&#xD;&#xA;                if($NoReboot -eq $false -and $InkFeatureResult.Success -and $InkFeatureResult.RestartNeeded -eq &quot;Yes&quot;)&#xD;&#xA;                {&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Result: $($InkFeatureResult.Success)&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: RestartNeeded: $($InkFeatureResult.RestartNeeded)&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Feature removed successfully.&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Rebooting...&quot;&#xD;&#xA;                    Restart-Computer -Force&#xD;&#xA;                    Sleep 10&#xD;&#xA;                }&#xD;&#xA;                &#xD;&#xA;                elseif(($NoReboot -eq $false) -and ($InkFeatureResult.Success -eq $false) -and ($InkFeatureResult.RestartNeeded -eq &quot;Yes&quot;))&#xD;&#xA;                {&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Result: $($InkFeatureResult.Success)&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: RestartNeeded: $($InkFeatureResult.RestartNeeded)&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Reboot already pending. Rebooting...&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Rebooting...&quot;&#xD;&#xA;                    Restart-Computer -Force&#xD;&#xA;                    Sleep 10&#xD;&#xA;                }&#xD;&#xA;                else&#xD;&#xA;                {    &#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Result: $($DEFeatureResult.Success)&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: RestartNeeded: $($DEFeatureResult.RestartNeeded)&quot;                &#xD;&#xA;                    LogEntry &quot;Reboot Required: *** MANUAL REBOOT REQUIRED ***&quot;&#xD;&#xA;                    Exit&#xD;&#xA;                }              &#xD;&#xA;            }&#xD;&#xA;            elseif(($InkStatus -eq $false -and $InkStatusInit -eq 0) -or ($InkStatus -eq $true -and $InkStatusInit -eq 1))&#xD;&#xA;            {&#xD;&#xA;                #Ink removed, update status&#xD;&#xA;                LogEntry &quot;PhaseSageRunComplete: Ink Removed. Updating status...&quot;&#xD;&#xA;                Set-ItemProperty -Path $ScriptRegKey -Name $ScriptRegValueName -Value $PhaseDERemoved&#xD;&#xA;            }          &#xD;&#xA;            else&#xD;&#xA;            {      &#xD;&#xA;                LogEntry &quot;PhaseSageRunComplete: Error removing Ink-Handwriting.&quot;            &#xD;&#xA;                LogEntry $Error[0].Exception&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            $CurrentState = GetCurrentState&#xD;&#xA;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        catch&#xD;&#xA;        {&#xD;&#xA;            LogEntry &quot;PhaseSageRunComplete: Caught Exception.&quot;&#xD;&#xA;            LogEntry &quot;$($Error[0].Exception)&quot;&#xD;&#xA;        } &#xD;&#xA;        break       &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    $PhaseDERemoved&#xD;&#xA;    {&#xD;&#xA;        try&#xD;&#xA;        {&#xD;&#xA;            #Retrieving initial space&#xD;&#xA;            $SpaceAtStart = (Get-ItemProperty -Path $ScriptRegKey -Name $ScriptSpaceBeforeValue).&quot;$ScriptSpaceBeforeValue&quot;&#xD;&#xA;&#xD;&#xA;            #remove reg key                        &#xD;&#xA;            LogEntry &quot;PhaseDERemoved: Removing Script Reg Key.&quot;&#xD;&#xA;            Remove-Item $ScriptRegKey            &#xD;&#xA;            $CurrentState = $PhaseTaskRemoved&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        catch&#xD;&#xA;        {&#xD;&#xA;            LogEntry &quot;PhaseDERemoved: ERROR.&quot;            &#xD;&#xA;            LogEntry $Error[0].Exception&#xD;&#xA;        }&#xD;&#xA;        break&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;   &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;#Prevents infinite loops consuming resources.&#xD;&#xA;Sleep 1&#xD;&#xA;&#xD;&#xA;} until ($CurrentState -eq $PhaseTaskRemoved)&#xD;&#xA;&#xD;&#xA;if($CurrentState -eq $PhaseTaskRemoved)&#xD;&#xA;{&#xD;&#xA;    try&#xD;&#xA;    {&#xD;&#xA;        LogEntry &quot;PhaseTaskRemoved: Removing Scheduled Task&quot;&#xD;&#xA;        DeleteScheduledTask -TaskName $SchTaskName&#xD;&#xA;        LogEntry &quot;PhaseTaskRemoved: Scheduled Task Deleted.&quot;&#xD;&#xA;        LogEntry &quot;PhaseTaskRemoved: Script Complete.&quot;&#xD;&#xA;&#xD;&#xA;        $CurrentSpace = (Get-WmiObject win32_logicaldisk | where { $_.DeviceID -eq $env:SystemDrive }).FreeSpace&#xD;&#xA;        LogEntry &quot;PhaseTaskRemoved: Current Disk Space: $([Math]::Round(($CurrentSpace / 1GB),2)) GB&quot;&#xD;&#xA;        &#xD;&#xA;        $Savings = [Math]::Round(((($CurrentSpace / $SpaceAtStart) - 1) * 100),2)&#xD;&#xA;&#xD;&#xA;$message = @&quot;&#xD;&#xA;****** CleanMgr complete.&#xD;&#xA;****** Starting Free Space: $SpaceAtStart&#xD;&#xA;****** Current Free Space: $CurrentSpace&#xD;&#xA;****** Savings: $Savings%&#xD;&#xA;****** Exiting.&#xD;&#xA;&quot;@&#xD;&#xA;&#xD;&#xA;        LogEntry $message&#xD;&#xA;   }&#xD;&#xA;&#xD;&#xA;   catch&#xD;&#xA;   {&#xD;&#xA;    LogEntry &quot;PhaseTaskRemoved: Error during PhaseTaskRemoved...&quot;&#xD;&#xA;    LogEntry $Error[0].Exception&#xD;&#xA;   }&#xD;&#xA;&#xD;&#xA;   Exit&#xD;&#xA;}" />
  <Code Content="&lt;#----------------------------------------------------------------------------&#xD;&#xA;LEGAL DISCLAIMER &#xD;&#xA;This Sample Code is provided for the purpose of illustration only and is not &#xD;&#xA;intended to be used in a production environment.  THIS SAMPLE CODE AND ANY &#xD;&#xA;RELATED INFORMATION ARE PROVIDED &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER &#xD;&#xA;EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF &#xD;&#xA;MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.  We grant You a &#xD;&#xA;nonexclusive, royalty-free right to use and modify the Sample Code and to &#xD;&#xA;reproduce and distribute the object code form of the Sample Code, provided &#xD;&#xA;that You agree: (i) to not use Our name, logo, or trademarks to market Your &#xD;&#xA;software product in which the Sample Code is embedded; (ii) to include a valid &#xD;&#xA;copyright notice on Your software product in which the Sample Code is embedded; &#xD;&#xA;and (iii) to indemnify, hold harmless, and defend Us and Our suppliers from and &#xD;&#xA;against any claims or lawsuits, including attorneys’ fees, that arise or result &#xD;&#xA;from the use or distribution of the Sample Code. &#xD;&#xA;  &#xD;&#xA;This posting is provided &quot;AS IS&quot; with no warranties, and confers no rights. Use &#xD;&#xA;of included script samples are subject to the terms specified &#xD;&#xA;at http://www.microsoft.com/info/cpyright.htm. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Author: Tom Moser, PFE&#xD;&#xA;Date: 5/13/2014&#xD;&#xA;Update1: 1/2/2015&#xD;&#xA;&#xD;&#xA;Version 1.0&#xD;&#xA;-Initial Release&#xD;&#xA;&#xD;&#xA;Version 1.1&#xD;&#xA;-Bug fixes&#xD;&#xA;    -Remove Ink and Handwriting Feature&#xD;&#xA;    -Fix typos in KB&#xD;&#xA;    -Change test to see if hotfix is installed&#xD;&#xA;-Thanks to all of the Script Center commenters for feedback!&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Usage: .\Cleanup-Disk.Ps1 [-NoReboot] [-LogPath &lt;String&gt;]&#xD;&#xA;&#xD;&#xA;Switch: NoReboot - Specify this switch ONLY if you DO NOT want the server to reboot&#xD;&#xA;        post update. It is recommendend that you do NOT use this switch.&#xD;&#xA;&#xD;&#xA;        LogPath - Specify this parameter with a log location to write out the script log.&#xD;&#xA;                  Will default to log.txt in the script directory.&#xD;&#xA;&#xD;&#xA;Notes: In order to schedule the script successfully, the name must remain Cleanup-Disk.ps1.&#xD;&#xA;       The log file will contain all relevent information - no console output should be expected. &#xD;&#xA;&#xD;&#xA;Summary:&#xD;&#xA;    This script requires KB2852386.&#xD;&#xA;&#xD;&#xA;    The script itself will perform the following:&#xD;&#xA;        -Verify the KB is installed &#xD;&#xA;        -Install the Desktop Experience feature &#xD;&#xA;        -Install a scheduled task that restarts the script 60 seconds after reboot &#xD;&#xA;        -Reboot, if necessary &#xD;&#xA;        -Update registry keys for cleanmgr.exe to run. &#xD;&#xA;        -Run cleanmgr.exe &#xD;&#xA;        -Reboot &#xD;&#xA;        -Remove Desktop Experience &#xD;&#xA;        -Reboot &#xD;&#xA;        -Remove scheduled task &#xD;&#xA;        -Exit &#xD;&#xA;&#xD;&#xA;-----------------------------------------------------------------------------#&gt;&#xD;&#xA;#Requires -RunAsAdministrator &#xD;&#xA;#Requires -Module ServerManager&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Param([string]$LogPath=&quot;$(join-path $(split-path -parent $MyInvocation.MyCommand.Definition) log.txt)&quot;,      &#xD;&#xA;      [switch]$NoReboot=$false)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;if((get-hotfix KB2852386).HotFixID -ne &quot;KB2852386&quot;)&#xD;&#xA;{&#xD;&#xA;    Write-Error &quot;KB2852386 is required for script. Please install hotfix and re-run.&quot;&#xD;&#xA;    Exit&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#Reg Paths/Vars&#xD;&#xA;Set-Variable -Name ScriptRegKey -Value &quot;HKLM:\Software\WinSXSCleanup&quot; -Option Constant&#xD;&#xA;Set-Variable -Name ScriptRegValueName -Value &quot;Phase&quot; -Option Constant&#xD;&#xA;Set-Variable -Name ScriptSageValueName -Value &quot;SageSet&quot; -Option Constant&#xD;&#xA;Set-Variable -Name ScriptSpaceBeforeValue -Value &quot;SpaceBefore&quot; -Option Constant&#xD;&#xA;Set-Variable -Name SchTaskName -Value &quot;CleanMgr Task Cleanup&quot; -Option Constant&#xD;&#xA;Set-Variable -Name ScriptDEStatusatStart -Value &quot;DEInstalledAtStart&quot; -Option Constant&#xD;&#xA;Set-Variable -Name ScriptInkStatusAtStart -Value &quot;InkInstalledAtStart&quot; -Option Constant&#xD;&#xA;Set-Variable -Name UpdateCleanupPath -value &quot;HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VolumeCaches\Update Cleanup&quot; -Option Constant&#xD;&#xA;Set-Variable -Name ServicePackCleanupPath -Value &quot;HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VolumeCaches\Service Pack Cleanup&quot; -Option Constant&#xD;&#xA;Set-Variable -Name VolumeCachesPath -Value &quot;HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VolumeCaches&quot; -Option Constant&#xD;&#xA;Set-Variable -Name StateFlagClean -Value 2 -Option Constant&#xD;&#xA;Set-Variable -Name StateFlagNoAction -Value 0 -Option Constant&#xD;&#xA;&#xD;&#xA;$ScriptPath = split-path -parent $MyInvocation.MyCommand.Definition&#xD;&#xA;&#xD;&#xA;#Phase Constants&#xD;&#xA;Set-Variable -Name PhaseInit -Value -1 -Option Constant&#xD;&#xA;Set-Variable -Name PhaseStarted -Value 0 -Option Constant&#xD;&#xA;Set-Variable -Name PhaseDEInstalled -Value 1 -Option Constant&#xD;&#xA;Set-Variable -Name PhaseSageSetComplete -Value 2 -Option Constant&#xD;&#xA;Set-Variable -Name PhaseSageRunStarted -Value 3 -Option Constant&#xD;&#xA;Set-Variable -Name PhaseSageRunComplete -Value 4 -Option Constant&#xD;&#xA;Set-Variable -Name PhaseDERemoved -Value 5 -Option Constant&#xD;&#xA;Set-Variable -Name PhaseTaskRemoved -Value 6 -Option Constant&#xD;&#xA;&#xD;&#xA;#import-module&#xD;&#xA;Import-Module ServerManager&#xD;&#xA;&#xD;&#xA;#read state value, use switch statement&#xD;&#xA;&#xD;&#xA;Function DateStamp&#xD;&#xA;{&#xD;&#xA;    return &quot;$(Get-Date -UFormat %Y%m%d-%H%M%S):&quot;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Function LogEntry([string]$LogData)&#xD;&#xA;{&#xD;&#xA;    Add-Content $LogPath &quot;$(DateStamp) $LogData&quot;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Function GetCurrentState&#xD;&#xA;{&#xD;&#xA;   return (Get-ItemProperty -Path $ScriptRegKey -Name $ScriptRegValueName -ErrorAction SilentlyContinue).Phase&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Function CreateScheduledTask&#xD;&#xA;{&#xD;&#xA;    Param([string]$ScriptPath, &#xD;&#xA;          [string]$TaskName,&#xD;&#xA;          [string]$fLogPath,&#xD;&#xA;          [string]$fNoReboot=$false)&#xD;&#xA;    try&#xD;&#xA;    {&#xD;&#xA;        $Scheduler = New-Object -ComObject &quot;Schedule.Service&quot;&#xD;&#xA;        $Scheduler.Connect(&quot;Localhost&quot;)&#xD;&#xA;        $root = $Scheduler.GetFolder(&quot;\&quot;)&#xD;&#xA;        $newTask = $Scheduler.NewTask(0)&#xD;&#xA;        $newTask.RegistrationInfo.Author = $TaskName&#xD;&#xA;        $newTask.RegistrationInfo.Description = &quot;&quot;&#xD;&#xA;        $newtask.Settings.StartWhenAvailable = $true&#xD;&#xA;        $trigger = $newTask.Triggers.Create(8) #Trigger at boot&#xD;&#xA;        $trigger.Delay = &quot;PT60S&quot;&#xD;&#xA;        $trigger.Id = &quot;LogonTriggerId&quot;&#xD;&#xA;        $newTask.Principal.UserId = &quot;NT AUTHORITY\SYSTEM&quot;&#xD;&#xA;        $newTask.Principal.RunLevel = 1&#xD;&#xA;        $newTask.Principal.LogonType = 5&#xD;&#xA;&#xD;&#xA;        $action = $newtask.Actions.Create(0)&#xD;&#xA;        $action.Path = &quot;C:\Windows\system32\WindowsPowerShell\v1.0\powershell.exe&quot;&#xD;&#xA;        &#xD;&#xA;        if($fNoReboot -eq $true)&#xD;&#xA;        {&#xD;&#xA;            $action.Arguments = &quot;-command `&quot;$(join-path $ScriptPath cleanup-disk.ps1)`&quot; -LogPath `&quot;$fLogPath`&quot; -NoReboot -NonInteractive -NoLogo -Version 2&quot;&#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;            $action.Arguments = &quot;-command `&quot;$(join-path $ScriptPath cleanup-disk.ps1)`&quot; -LogPath `&quot;$fLogPath`&quot; -NonInteractive -NoLogo -Version 2&quot;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        $root.RegisterTaskDefinition(&quot;CleanMgr Cleanup Task&quot;, $newTask, 6, &quot;NT AUTHORITY\SYSTEM&quot;, $null , 4)&#xD;&#xA;    }&#xD;&#xA;    catch&#xD;&#xA;    {&#xD;&#xA;        LogEntry &quot;Failed to register scheduled task.&quot; &#xD;&#xA;        LogEntry $Error[0].Exception&#xD;&#xA;        throw &quot;Failed to register scheduled task...&quot;&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;Function DeleteScheduledTask&#xD;&#xA;{&#xD;&#xA;    Param([string]$TaskName)&#xD;&#xA;    c:\windows\system32\schtasks.exe /delete /TN &quot;CleanMgr Cleanup Task&quot; /f&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Function CheckPendingReboot&#xD;&#xA;{&#xD;&#xA;    return Test-Path &quot;HKLM:\Software\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending&quot;    &#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;if(Test-Path $ScriptRegKey)&#xD;&#xA;{&#xD;&#xA;    $CurrentState = GetCurrentState&#xD;&#xA;}&#xD;&#xA;else&#xD;&#xA;{&#xD;&#xA;    $CurrentState = $PhaseInit&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;if(($CurrentState -eq $PhaseInit) -and (CheckPendingReboot -eq $true))&#xD;&#xA;{&#xD;&#xA;    Write-Host -ForegroundColor 'Red' &quot;Reboot pending. Please reboot system and rerun script.&quot;&#xD;&#xA;    LogEntry &quot;*** Reboot pending during initial phase. Reboot and rerun script!&quot;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;LogEntry &quot;CurrentState: $CurrentState&quot;&#xD;&#xA;LogEntry &quot;NoReboot Flag: $NoReboot&quot;&#xD;&#xA;&#xD;&#xA;do&#xD;&#xA;{&#xD;&#xA;    LogEntry &quot;**** Current State: $CurrentState&quot;&#xD;&#xA;&#xD;&#xA;    #Evalute current state against all possibilities.&#xD;&#xA;    Switch($CurrentState)&#xD;&#xA;    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               &#xD;&#xA;    &#xD;&#xA;    $PhaseInit&#xD;&#xA;    {        &#xD;&#xA;        LogEntry &quot;Switch: Null&quot;&#xD;&#xA;&#xD;&#xA;        try&#xD;&#xA;        {   &#xD;&#xA;            #Calculate and log freespace        &#xD;&#xA;            $FreeSpace = (Get-WmiObject win32_logicaldisk | where { $_.DeviceID -eq $env:SystemDrive }).FreeSpace&#xD;&#xA;            if((Test-Path $ScriptRegKey) -eq $false)&#xD;&#xA;            {&#xD;&#xA;                New-Item -Path $ScriptRegKey&#xD;&#xA;            }&#xD;&#xA;            Set-ItemProperty -Path $ScriptRegKey -Name $ScriptSpaceBeforeValue -Value $FreeSpace&#xD;&#xA;            LogEntry &quot;PhaseInit: Current Free Space: $([Math]::Round(($FreeSpace / 1GB),2))GB&quot;&#xD;&#xA;            &#xD;&#xA;             #Check to see if DE is already installed.&#xD;&#xA;            #If yes, set reg key to 1, else 0. Used to prevent DE from uninstalling unintentionally.&#xD;&#xA;            if((Get-WindowsFeature Desktop-Experience).Installed -eq $true)&#xD;&#xA;            {&#xD;&#xA;                Set-ItemProperty -Path $ScriptRegKey -name $ScriptDEStatusAtStart -Value 1&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {&#xD;&#xA;                Set-ItemProperty -Path $ScriptRegKey -name $ScriptDEStatusAtStart -Value 0&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            if((Get-WindowsFeature Ink-Handwriting).Installed -eq $true)&#xD;&#xA;            {&#xD;&#xA;                Set-ItemProperty -Path $ScriptRegKey -Name $ScriptInkStatusAtStart -Value 1&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {&#xD;&#xA;                Set-ItemProperty -Path $ScriptRegKey -Name $ScriptInkStatusAtStart -Value 0&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            &#xD;&#xA;            #Start Installing DE                        &#xD;&#xA;            LogEntry &quot;Feature: Installing Desktop Experience.&quot; &#xD;&#xA;            $FeatureResult = Add-WindowsFeature Desktop-Experience&#xD;&#xA;            LogEntry &quot;PhaseInit: Feature: ExitCode: $($FeatureResult.ExitCode)&quot;&#xD;&#xA;            LogEntry &quot;PhaseInit: Feature: RestartRequired: $($FeatureResult.RestartNeeded)&quot;&#xD;&#xA;            LogEntry &quot;PhaseInit: Feature: Success: $($FeatureResult.Success)&quot;&#xD;&#xA;&#xD;&#xA;            #If DE fails, throw error. &#xD;&#xA;            if($FeatureResult.Success -eq $false -and $FeatureResult.RestartNeeded -eq &quot;No&quot;)&#xD;&#xA;            {&#xD;&#xA;                throw &quot;PhaseInit: Failed to install Desktop Experience. This is a required feature for WinSXS Cleanup.&quot;&#xD;&#xA;            }&#xD;&#xA;           &#xD;&#xA;            #If DE exists with no change needed or success, update reg keys. Reboot if required. Create task.&#xD;&#xA;            elseif($FeatureResult.ExitCode -eq &quot;NoChangeNeeded&quot; -or ($FeatureResult.Success))&#xD;&#xA;            {&#xD;&#xA;                LogEntry &quot;PhaseInit: Feature: Desktop Experience Installed. Updating $ScriptRegKey\$ScriptRegValueName to $PhaseStarted&quot;&#xD;&#xA;                #New-Item $ScriptRegKey -Force&#xD;&#xA;                New-ItemProperty -Path $ScriptRegKey -Name $ScriptRegValueName -Value $PhaseStarted -Force&#xD;&#xA;                &#xD;&#xA;                if($NoReboot -eq $false -and $FeatureResult.RestartNeeded -eq &quot;Yes&quot;)&#xD;&#xA;                {                    &#xD;&#xA;                    LogEntry &quot;PhastInit: Creating Scheduled Task...&quot;&#xD;&#xA;                    CreateScheduledTask -ScriptPath $ScriptPath -TaskName $SchTaskName -fLogPath $LogPath &#xD;&#xA;                    LogEntry &quot;PhaseInit: Created Scheduled Task $SchTaskName&quot;                    &#xD;&#xA;                    $CurrentState = GetCurrentState&#xD;&#xA;                    Restart-Computer&#xD;&#xA;                    Sleep 10&#xD;&#xA;                }&#xD;&#xA;                elseif($FeatureResult.ExitCode -eq &quot;NoChangeNeeded&quot;)&#xD;&#xA;                {&#xD;&#xA;                    LogEntry &quot;DE Already Installed. No reboot required.&quot;&#xD;&#xA;                    LogEntry &quot;PhastInit: Creating Scheduled Task...&quot;&#xD;&#xA;                    CreateScheduledTask -ScriptPath &quot;$ScriptPath&quot; -TaskName $SchTaskName -fLogPath $LogPath -fNoReboot &quot;`$$NoReboot&quot;&#xD;&#xA;                    LogEntry &quot;PhaseInit: Created Scheduled Task $SchTaskName&quot;&#xD;&#xA;&#xD;&#xA;                    $CurrentState = GetCurrentState&#xD;&#xA;                }                &#xD;&#xA;                else&#xD;&#xA;                {&#xD;&#xA;                    CreateScheduledTask -ScriptPath &quot;$ScriptPath&quot; -TaskName $SchTaskName -fLogPath $LogPath -fNoReboot &quot;`$$NoReboot&quot;&#xD;&#xA;                    LogEntry &quot;Phaseinit: Restart switch not specified. Please manually reboot the server to continue cleanup.&quot;&#xD;&#xA;                    Exit&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        catch&#xD;&#xA;        {&#xD;&#xA;            LogEntry $error[0]&#xD;&#xA;            exit&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        break&#xD;&#xA;    }           &#xD;&#xA;&#xD;&#xA;    $PhaseStarted&#xD;&#xA;    {&#xD;&#xA;      LogEntry &quot;PhaseStarted: Verifying DE installation...&quot;&#xD;&#xA;      if((Get-WindowsFeature Desktop-Experience).Installed -eq $true) #check for pending reboot&#xD;&#xA;      {&#xD;&#xA;        LogEntry &quot;PhaseStarted: DE Installed. Moving to PhaseDEInstalled.&quot;&#xD;&#xA;        Set-ItemProperty -Path $ScriptRegKey -Name $ScriptRegValueName -Value $PhaseDEInstalled&#xD;&#xA;      }&#xD;&#xA;      Else&#xD;&#xA;      {&#xD;&#xA;        LogEntry &quot;PhaseStarted: DE not installed. Resetting phase to null.&quot;&#xD;&#xA;        New-ItemProperty -Path $ScriptRegKey -Name $ScriptRegValueName -Value $null&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;      $CurrentState = GetCurrentState&#xD;&#xA;      break&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    $PhaseDEInstalled&#xD;&#xA;    {&#xD;&#xA;        try&#xD;&#xA;        {&#xD;&#xA;            LogEntry &quot;PhaseDEInstalled: Starting PhaseDEInstalled...&quot;&#xD;&#xA;            LogEntry &quot;PhaseDEInstalled: Setting SagetSet...&quot;&#xD;&#xA;            #use static SageSet Value. Insert in to registry.&#xD;&#xA;            $SageSet = &quot;0010&quot;&#xD;&#xA;            Set-Variable -Name StateFlags -Value &quot;StateFlags$SageSet&quot; -Option Constant          &#xD;&#xA;            LogEntry &quot;PhaseDEInstalled: SageSet complete.&quot;&#xD;&#xA;            LogEntry &quot;PhaseDEInstalled: Setting VolumeCaches reg keys...&quot;&#xD;&#xA;            #Set all VolumeCache keys to StateFlags = 0 to prevent cleanup. After, set the proper keys to 2 to allow cleanup.&#xD;&#xA;            $SubKeys = Get-Childitem HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VolumeCaches&#xD;&#xA;            Foreach ($Key in $SubKeys)&#xD;&#xA;            {&#xD;&#xA;                Set-ItemProperty -Path $Key.PSPath -Name $StateFlags -Value $StateFlagNoAction&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            LogEntry &quot;PhaseDEInstalled: VolumeCaches keys set.&quot;&#xD;&#xA;            LogEntry &quot;PhaseDEInstalled: Setting UPdate and Service Pack Keys...&quot;&#xD;&#xA;            #Set all script reg values for persistence through reboots.&#xD;&#xA;            Set-ItemProperty -Path $ScriptRegKey -Name $ScriptSageValueName -Value $SageSet&#xD;&#xA;            Set-ItemProperty -Path $UpdateCleanUpPath -Name $StateFlags -Value $StateFlagClean&#xD;&#xA;            Set-ItemProperty -Path $ServicePackCleanUpPath -Name $StateFlags -Value $StateFlagClean                                                                &#xD;&#xA;            LogEntry &quot;PhaseDEInstalled: Done.&quot; &#xD;&#xA;&#xD;&#xA;            #Update state key&#xD;&#xA;            Set-ItemProperty -Path $ScriptRegKey -Name $ScriptRegValueName -Value $PhaseSageSetComplete&#xD;&#xA;            $CurrentState = GetCurrentState&#xD;&#xA;            LogEntry &quot;PhaseDEInstalled: Complete.&quot;&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        catch&#xD;&#xA;        {&#xD;&#xA;            LogEntry &quot;PhaseDEInstalled: Failed to update reg keys.&quot;&#xD;&#xA;            LogEntry $Error[0].Exception&#xD;&#xA;        }&#xD;&#xA;        break&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    $PhaseSageSetComplete&#xD;&#xA;    {&#xD;&#xA;        LogEntry &quot;PhaseSageSetComplete: Starting cleanmgr.&quot;&#xD;&#xA;        try&#xD;&#xA;        {&#xD;&#xA;            $SageSet = (Get-ItemProperty -Path $ScriptRegKey -Name $ScriptSageValueName).SageSet&#xD;&#xA;                        &#xD;&#xA;            LogEntry &quot;PhaseSageSetComplete: CleanMgr.exe running... &quot;            &#xD;&#xA;            $StartTime = Get-Date&#xD;&#xA;            &amp;&quot;C:\Windows\System32\Cleanmgr.exe&quot; + &quot; /sagerun:$SageSet&quot;            &#xD;&#xA;            Wait-Process cleanmgr&#xD;&#xA;            $EndTime = Get-Date&#xD;&#xA;            LogEntry &quot;PhaseSageSetComplete: CleanMgr.exe complete...&quot;&#xD;&#xA;            LogEntry &quot;PhaseSageSetComplete: Seconds Elapsed: $((New-TimeSpan $StartTime $EndTime).TotalSeconds)&quot;&#xD;&#xA;            LogEntry &quot;PhaseSageSetComplete: Updating State...&quot;&#xD;&#xA;            Set-ItemProperty -Path $ScriptRegKey -Name $ScriptRegValueName -Value $PhaseSageRunComplete&#xD;&#xA;            $CurrentState = GetCurrentState&#xD;&#xA;            LogEntry &quot;PhaseSageSetComplete: Complete.&quot;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        catch&#xD;&#xA;        {&#xD;&#xA;            LogEntry &quot;PhaseSageSetComplete: ERROR.&quot;            &#xD;&#xA;            LogEntry $Error[0].Exception&#xD;&#xA;        }    &#xD;&#xA;        break    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    $PhaseSageRunComplete&#xD;&#xA;    {&#xD;&#xA;        try&#xD;&#xA;        {   &#xD;&#xA;            $DEStatusInit = (Get-ItemProperty -Path $ScriptRegKey -Name $ScriptDEStatusAtStart).&quot;$ScriptDEStatusAtStart&quot;&#xD;&#xA;            $InkStatusInit = (Get-ItemProperty -Path $scriptRegKey -Name $ScriptInkStatusAtStart).&quot;$ScriptInkStatusAtStart&quot;&#xD;&#xA;&#xD;&#xA;            LogEntry &quot;PhaseSageRunComplete: Starting PhaseSageRunComplete.&quot;&#xD;&#xA;            LogEntry &quot;PhaseSageRunComplete: Getting DE Status.&quot;&#xD;&#xA;            &#xD;&#xA;            $DEStatus = (Get-WindowsFeature Desktop-Experience).Installed&#xD;&#xA;            $InkStatus = (Get-WindowsFeature Ink-Handwriting).Installed&#xD;&#xA;&#xD;&#xA;            if($DEStatus -and $DEStatusInit -eq 0)&#xD;&#xA;            {&#xD;&#xA;                $RemoveDE = $true&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {&#xD;&#xA;                $RemoveDE = $false&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            if($InkStatus -and $InkStatusInit -eq 0)&#xD;&#xA;            {&#xD;&#xA;               $RemoveInk = $true&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {&#xD;&#xA;                $RemoveInk = $false&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            LogEntry &quot;PhaseSageRunComplete: DEInstalled = $DEStatus&quot;&#xD;&#xA;            LogEntry &quot;PhaseSageRunComplete: DEStatus at Start was $DEStatusInit&quot;&#xD;&#xA;            LogEntry &quot;PhaseSageRunComplete: RemoveDE is $RemoveDE&quot;&#xD;&#xA;            LogEntry &quot;PhaseSageRunComplete: InkInstalled = $InkStatus&quot;&#xD;&#xA;            LogEntry &quot;PhaseSageRunComplete: InkStatus at start was $InkStatusInit&quot;&#xD;&#xA;            LogEntry &quot;PhaseSageRunComplete: RemoveInk is $RemoveInk&quot;            &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;            #if($DEStatusInit -eq 1)&#xD;&#xA;            if($RemoveDE -eq $false)&#xD;&#xA;            {&#xD;&#xA;                LogEntry &quot;PhaseSageRunComplete: DE removal not required. Continuing...&quot;&#xD;&#xA;                Set-ItemProperty -Path $ScriptRegKey -Name $ScriptRegValueName -Value $PhaseDERemoved&#xD;&#xA;                $CurrentState = GetCurrentState&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            #remove DE if it was not installed                       &#xD;&#xA;            if($RemoveDE -eq $true)&#xD;&#xA;            {                &#xD;&#xA;                if($RemoveInk -eq $true)&#xD;&#xA;                {       &#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Removing DE and Ink-Handwriting&quot;             &#xD;&#xA;                    $DEFeatureResult = (Remove-WindowsFeature Desktop-Experience,Ink-Handwriting)                                    &#xD;&#xA;                }&#xD;&#xA;                else&#xD;&#xA;                {&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Removing only DE.&quot;&#xD;&#xA;                    $DEFeatureResult = (Remove-WindowsFeature Desktop-Experience)                   &#xD;&#xA;                }&#xD;&#xA;                           &#xD;&#xA;                if($NoReboot -eq $false -and $DEFeatureResult.Success -and $DEFeatureResult.RestartNeeded -eq &quot;Yes&quot;)&#xD;&#xA;                {&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Result: $($DEFeatureResult.Success)&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: RestartNeeded: $($DEFeatureResult.RestartNeeded)&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Feature removed successfully.&quot;&#xD;&#xA;                   &#xD;&#xA;                    if($RemoveInk -eq $false)&#xD;&#xA;                    { &#xD;&#xA;                        LogEntry &quot;PhaseSageRunComplete: Rebooting...&quot;&#xD;&#xA;                        Restart-Computer -Force&#xD;&#xA;                        Sleep 10&#xD;&#xA;                    }&#xD;&#xA;                    else&#xD;&#xA;                    {&#xD;&#xA;                        LogEntry &quot;PhaseSageRunComplete: Postponing reboot to remove Ink-Handwriting...&quot;&#xD;&#xA;                    }&#xD;&#xA;                   &#xD;&#xA;                }&#xD;&#xA;                elseif(($NoReboot -eq $false) -and ($DEFeatureResult.Success -eq $false) -and ($DEFeatureResult.RestartNeeded -eq &quot;Yes&quot;))&#xD;&#xA;                {&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Result: $($DEFeatureResult.Success)&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: RestartNeeded: $($DEFeatureResult.RestartNeeded)&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Reboot already pending. Rebooting...&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Rebooting...&quot;&#xD;&#xA;                    Restart-Computer -Force&#xD;&#xA;                    Sleep 10&#xD;&#xA;                }&#xD;&#xA;                Else&#xD;&#xA;                {    &#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Result: $($DEFeatureResult.Success)&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: RestartNeeded: $($DEFeatureResult.RestartNeeded)&quot;                &#xD;&#xA;                    LogEntry &quot;Reboot Required: *** MANUAL REBOOT REQUIRED ***&quot;&#xD;&#xA;                    Exit&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            elseif($DEStatus -eq $false -and $DEStatusInit -eq 0)&#xD;&#xA;            {&#xD;&#xA;                #DE removed, update status&#xD;&#xA;                LogEntry &quot;PhaseSageRunComplete: DE Removed. Updating status...&quot;&#xD;&#xA;                Set-ItemProperty -Path $ScriptRegKey -Name $ScriptRegValueName -Value $PhaseDERemoved&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {      &#xD;&#xA;                LogEntry &quot;PhaseSageRunComplete: ERROR.&quot;            &#xD;&#xA;                LogEntry $Error[0].Exception&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            if($RemoveInk -eq $true -and $RemoveDE -eq $false)&#xD;&#xA;            {&#xD;&#xA;                LogEntry &quot;PhaseSageRunComplete: Removing Ink-Handwriting&quot;&#xD;&#xA;                $InkFeatureResult = (Remove-WindowsFeature Ink-Handwriting)&#xD;&#xA;&#xD;&#xA;                if($NoReboot -eq $false -and $InkFeatureResult.Success -and $InkFeatureResult.RestartNeeded -eq &quot;Yes&quot;)&#xD;&#xA;                {&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Result: $($InkFeatureResult.Success)&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: RestartNeeded: $($InkFeatureResult.RestartNeeded)&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Feature removed successfully.&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Rebooting...&quot;&#xD;&#xA;                    Restart-Computer -Force&#xD;&#xA;                    Sleep 10&#xD;&#xA;                }&#xD;&#xA;                &#xD;&#xA;                elseif(($NoReboot -eq $false) -and ($InkFeatureResult.Success -eq $false) -and ($InkFeatureResult.RestartNeeded -eq &quot;Yes&quot;))&#xD;&#xA;                {&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Result: $($InkFeatureResult.Success)&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: RestartNeeded: $($InkFeatureResult.RestartNeeded)&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Reboot already pending. Rebooting...&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Rebooting...&quot;&#xD;&#xA;                    Restart-Computer -Force&#xD;&#xA;                    Sleep 10&#xD;&#xA;                }&#xD;&#xA;                else&#xD;&#xA;                {    &#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: Result: $($DEFeatureResult.Success)&quot;&#xD;&#xA;                    LogEntry &quot;PhaseSageRunComplete: RestartNeeded: $($DEFeatureResult.RestartNeeded)&quot;                &#xD;&#xA;                    LogEntry &quot;Reboot Required: *** MANUAL REBOOT REQUIRED ***&quot;&#xD;&#xA;                    Exit&#xD;&#xA;                }              &#xD;&#xA;            }&#xD;&#xA;            elseif(($InkStatus -eq $false -and $InkStatusInit -eq 0) -or ($InkStatus -eq $true -and $InkStatusInit -eq 1))&#xD;&#xA;            {&#xD;&#xA;                #Ink removed, update status&#xD;&#xA;                LogEntry &quot;PhaseSageRunComplete: Ink Removed. Updating status...&quot;&#xD;&#xA;                Set-ItemProperty -Path $ScriptRegKey -Name $ScriptRegValueName -Value $PhaseDERemoved&#xD;&#xA;            }          &#xD;&#xA;            else&#xD;&#xA;            {      &#xD;&#xA;                LogEntry &quot;PhaseSageRunComplete: Error removing Ink-Handwriting.&quot;            &#xD;&#xA;                LogEntry $Error[0].Exception&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            $CurrentState = GetCurrentState&#xD;&#xA;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        catch&#xD;&#xA;        {&#xD;&#xA;            LogEntry &quot;PhaseSageRunComplete: Caught Exception.&quot;&#xD;&#xA;            LogEntry &quot;$($Error[0].Exception)&quot;&#xD;&#xA;        } &#xD;&#xA;        break       &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    $PhaseDERemoved&#xD;&#xA;    {&#xD;&#xA;        try&#xD;&#xA;        {&#xD;&#xA;            #Retrieving initial space&#xD;&#xA;            $SpaceAtStart = (Get-ItemProperty -Path $ScriptRegKey -Name $ScriptSpaceBeforeValue).&quot;$ScriptSpaceBeforeValue&quot;&#xD;&#xA;&#xD;&#xA;            #remove reg key                        &#xD;&#xA;            LogEntry &quot;PhaseDERemoved: Removing Script Reg Key.&quot;&#xD;&#xA;            Remove-Item $ScriptRegKey            &#xD;&#xA;            $CurrentState = $PhaseTaskRemoved&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        catch&#xD;&#xA;        {&#xD;&#xA;            LogEntry &quot;PhaseDERemoved: ERROR.&quot;            &#xD;&#xA;            LogEntry $Error[0].Exception&#xD;&#xA;        }&#xD;&#xA;        break&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;   &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;#Prevents infinite loops consuming resources.&#xD;&#xA;Sleep 1&#xD;&#xA;&#xD;&#xA;} until ($CurrentState -eq $PhaseTaskRemoved)&#xD;&#xA;&#xD;&#xA;if($CurrentState -eq $PhaseTaskRemoved)&#xD;&#xA;{&#xD;&#xA;    try&#xD;&#xA;    {&#xD;&#xA;        LogEntry &quot;PhaseTaskRemoved: Removing Scheduled Task&quot;&#xD;&#xA;        DeleteScheduledTask -TaskName $SchTaskName&#xD;&#xA;        LogEntry &quot;PhaseTaskRemoved: Scheduled Task Deleted.&quot;&#xD;&#xA;        LogEntry &quot;PhaseTaskRemoved: Script Complete.&quot;&#xD;&#xA;&#xD;&#xA;        $CurrentSpace = (Get-WmiObject win32_logicaldisk | where { $_.DeviceID -eq $env:SystemDrive }).FreeSpace&#xD;&#xA;        LogEntry &quot;PhaseTaskRemoved: Current Disk Space: $([Math]::Round(($CurrentSpace / 1GB),2)) GB&quot;&#xD;&#xA;        &#xD;&#xA;        $Savings = [Math]::Round(((($CurrentSpace / $SpaceAtStart) - 1) * 100),2)&#xD;&#xA;&#xD;&#xA;$message = @&quot;&#xD;&#xA;****** CleanMgr complete.&#xD;&#xA;****** Starting Free Space: $SpaceAtStart&#xD;&#xA;****** Current Free Space: $CurrentSpace&#xD;&#xA;****** Savings: $Savings%&#xD;&#xA;****** Exiting.&#xD;&#xA;&quot;@&#xD;&#xA;&#xD;&#xA;        LogEntry $message&#xD;&#xA;   }&#xD;&#xA;&#xD;&#xA;   catch&#xD;&#xA;   {&#xD;&#xA;    LogEntry &quot;PhaseTaskRemoved: Error during PhaseTaskRemoved...&quot;&#xD;&#xA;    LogEntry $Error[0].Exception&#xD;&#xA;   }&#xD;&#xA;&#xD;&#xA;   Exit&#xD;&#xA;}" />
</CodeSnippets>